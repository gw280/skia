<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Skia: SkProxyCanvas Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>SkProxyCanvas Class Reference</h1><!-- doxytag: class="SkProxyCanvas" --><!-- doxytag: inherits="SkCanvas" -->
<p><code>#include &lt;<a class="el" href="_sk_proxy_canvas_8h_source.html">SkProxyCanvas.h</a>&gt;</code></p>

<p>Inherits <a class="el" href="class_sk_canvas.html">SkCanvas</a>.</p>
<div class="dynheader">
Collaboration diagram for SkProxyCanvas:</div>
<div class="dynsection">
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>

<p><a href="class_sk_proxy_canvas-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_proxy_canvas.html#a29444b8a946993196d9a608f6f3b0269">SkProxyCanvas</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_proxy_canvas.html#a2aedda8ab874267f5517a0aa711d12a3">SkProxyCanvas</a> (<a class="el" href="class_sk_canvas.html">SkCanvas</a> *proxy)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_proxy_canvas.html#a25128b790196fb7d77a36289ad3d4d69">~SkProxyCanvas</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_sk_canvas.html">SkCanvas</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_proxy_canvas.html#a90df240f9130ebdef3236a50a8e7064b">getProxy</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_proxy_canvas.html#a52c7f56652deb3357a599c449aa48ca6">setProxy</a> (<a class="el" href="class_sk_canvas.html">SkCanvas</a> *proxy)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_proxy_canvas.html#a32ee2a6b6ef25981da317be01e678723">getViewport</a> (<a class="el" href="struct_sk_i_point.html">SkIPoint</a> *size) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_proxy_canvas.html#a850d8cb87972a7eef443e82f969b4147">setViewport</a> (int x, int y)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_sk_device.html">SkDevice</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_proxy_canvas.html#aefeaaf9aba80b029adc658f1c920b2e1">setBitmapDevice</a> (const <a class="el" href="class_sk_bitmap.html">SkBitmap</a> &amp;bitmap)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_proxy_canvas.html#a58b8be5e635d770f00ef137b659833a4">save</a> (<a class="el" href="class_sk_canvas.html#a438a1ae606d773f95054f1df6ff2bdf2">SaveFlags</a> flags=kMatrixClip_SaveFlag)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_proxy_canvas.html#ae5c7919420c9ffbe737010dbc2213245">saveLayer</a> (const <a class="el" href="struct_sk_rect.html">SkRect</a> *bounds, const <a class="el" href="class_sk_paint.html">SkPaint</a> *paint, <a class="el" href="class_sk_canvas.html#a438a1ae606d773f95054f1df6ff2bdf2">SaveFlags</a> flags=kARGB_ClipLayer_SaveFlag)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_proxy_canvas.html#ac9b75e31170ca5506aeeca1bc2697a6d">restore</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_proxy_canvas.html#ab8241fc4f0904fc554f6b210da62031a">translate</a> (<a class="el" href="_sk_scalar_8h.html#a407e363d56d824ed93bd6d1fda2effcf">SkScalar</a> dx, <a class="el" href="_sk_scalar_8h.html#a407e363d56d824ed93bd6d1fda2effcf">SkScalar</a> dy)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_proxy_canvas.html#adc1ee09cc90b9e9cddf856fd15265dca">scale</a> (<a class="el" href="_sk_scalar_8h.html#a407e363d56d824ed93bd6d1fda2effcf">SkScalar</a> sx, <a class="el" href="_sk_scalar_8h.html#a407e363d56d824ed93bd6d1fda2effcf">SkScalar</a> sy)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_proxy_canvas.html#a221a3f017f8433479a0553e69e057df0">rotate</a> (<a class="el" href="_sk_scalar_8h.html#a407e363d56d824ed93bd6d1fda2effcf">SkScalar</a> degrees)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_proxy_canvas.html#a942460e35e38f19bfc603e19d49597ff">skew</a> (<a class="el" href="_sk_scalar_8h.html#a407e363d56d824ed93bd6d1fda2effcf">SkScalar</a> sx, <a class="el" href="_sk_scalar_8h.html#a407e363d56d824ed93bd6d1fda2effcf">SkScalar</a> sy)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_proxy_canvas.html#a2216920751c7f58c80791b1e81365c18">concat</a> (const <a class="el" href="class_sk_matrix.html">SkMatrix</a> &amp;matrix)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_proxy_canvas.html#ae65434deb607a05f68dc5a11ce4ccc71">setMatrix</a> (const <a class="el" href="class_sk_matrix.html">SkMatrix</a> &amp;matrix)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_proxy_canvas.html#a003658103e75cb322a4ed6459a9fb7da">clipRect</a> (const <a class="el" href="struct_sk_rect.html">SkRect</a> &amp;rect, <a class="el" href="class_sk_region.html#a2ced93c36095d876b020e20cf39f5b54">SkRegion::Op</a> op=SkRegion::kIntersect_Op)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_proxy_canvas.html#aaa37f01fd077adf3a0d3a28ae8448078">clipPath</a> (const <a class="el" href="class_sk_path.html">SkPath</a> &amp;path, <a class="el" href="class_sk_region.html#a2ced93c36095d876b020e20cf39f5b54">SkRegion::Op</a> op=SkRegion::kIntersect_Op)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_proxy_canvas.html#a3453740ab70feb3f3b3d2ceb1476a959">clipRegion</a> (const <a class="el" href="class_sk_region.html">SkRegion</a> &amp;deviceRgn, <a class="el" href="class_sk_region.html#a2ced93c36095d876b020e20cf39f5b54">SkRegion::Op</a> op=SkRegion::kIntersect_Op)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_proxy_canvas.html#a13ca3fabc375d1e0cdb11d2a89e89ba4">drawPaint</a> (const <a class="el" href="class_sk_paint.html">SkPaint</a> &amp;paint)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_proxy_canvas.html#a4b9dba4a0b4822f677d8d658b836cb15">drawPoints</a> (<a class="el" href="class_sk_canvas.html#af1bcd412326a6886e0f260d4d2dc757b">PointMode</a> mode, size_t count, const <a class="el" href="struct_sk_point.html">SkPoint</a> pts[], const <a class="el" href="class_sk_paint.html">SkPaint</a> &amp;paint)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_proxy_canvas.html#a5b8d732709f01d37fa8e5180c8d877dc">drawRect</a> (const <a class="el" href="struct_sk_rect.html">SkRect</a> &amp;rect, const <a class="el" href="class_sk_paint.html">SkPaint</a> &amp;paint)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_proxy_canvas.html#a8918e8cd9535dc5b464e9f69261c6918">drawPath</a> (const <a class="el" href="class_sk_path.html">SkPath</a> &amp;path, const <a class="el" href="class_sk_paint.html">SkPaint</a> &amp;paint)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_proxy_canvas.html#a9fb3db90b6da815509d5ac453a56e1a1">drawBitmap</a> (const <a class="el" href="class_sk_bitmap.html">SkBitmap</a> &amp;bitmap, <a class="el" href="_sk_scalar_8h.html#a407e363d56d824ed93bd6d1fda2effcf">SkScalar</a> left, <a class="el" href="_sk_scalar_8h.html#a407e363d56d824ed93bd6d1fda2effcf">SkScalar</a> top, const <a class="el" href="class_sk_paint.html">SkPaint</a> *paint=NULL)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_proxy_canvas.html#aab18deeef885832f73e50056af6826d1">drawBitmapRect</a> (const <a class="el" href="class_sk_bitmap.html">SkBitmap</a> &amp;bitmap, const <a class="el" href="struct_sk_i_rect.html">SkIRect</a> *src, const <a class="el" href="struct_sk_rect.html">SkRect</a> &amp;dst, const <a class="el" href="class_sk_paint.html">SkPaint</a> *paint=NULL)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_proxy_canvas.html#a2e82ee879d8d347e196115b11c7baf08">drawBitmapMatrix</a> (const <a class="el" href="class_sk_bitmap.html">SkBitmap</a> &amp;bitmap, const <a class="el" href="class_sk_matrix.html">SkMatrix</a> &amp;m, const <a class="el" href="class_sk_paint.html">SkPaint</a> *paint=NULL)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_proxy_canvas.html#a3f05a6956390d4d0b76546aa24ab988a">drawSprite</a> (const <a class="el" href="class_sk_bitmap.html">SkBitmap</a> &amp;bitmap, int left, int top, const <a class="el" href="class_sk_paint.html">SkPaint</a> *paint=NULL)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_proxy_canvas.html#aa4a4886ab97dca0ac689fa9b1850bbf9">drawText</a> (const void *text, size_t byteLength, <a class="el" href="_sk_scalar_8h.html#a407e363d56d824ed93bd6d1fda2effcf">SkScalar</a> x, <a class="el" href="_sk_scalar_8h.html#a407e363d56d824ed93bd6d1fda2effcf">SkScalar</a> y, const <a class="el" href="class_sk_paint.html">SkPaint</a> &amp;paint)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_proxy_canvas.html#ab87a00cb9ec1210c85e9acaa772dae52">drawPosText</a> (const void *text, size_t byteLength, const <a class="el" href="struct_sk_point.html">SkPoint</a> pos[], const <a class="el" href="class_sk_paint.html">SkPaint</a> &amp;paint)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_proxy_canvas.html#ac5bfca39aadc8144354e318379f74902">drawPosTextH</a> (const void *text, size_t byteLength, const <a class="el" href="_sk_scalar_8h.html#a407e363d56d824ed93bd6d1fda2effcf">SkScalar</a> xpos[], <a class="el" href="_sk_scalar_8h.html#a407e363d56d824ed93bd6d1fda2effcf">SkScalar</a> constY, const <a class="el" href="class_sk_paint.html">SkPaint</a> &amp;paint)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_proxy_canvas.html#a35fb9745a41680ce65e16e9c01d2891c">drawTextOnPath</a> (const void *text, size_t byteLength, const <a class="el" href="class_sk_path.html">SkPath</a> &amp;path, const <a class="el" href="class_sk_matrix.html">SkMatrix</a> *matrix, const <a class="el" href="class_sk_paint.html">SkPaint</a> &amp;paint)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_proxy_canvas.html#af80b45954f57f0c8167e43262aa089c9">drawPicture</a> (<a class="el" href="class_sk_picture.html">SkPicture</a> &amp;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_proxy_canvas.html#a4939b793160552abef82098978eb4081">drawShape</a> (<a class="el" href="class_sk_shape.html">SkShape</a> *)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_proxy_canvas.html#af31d9276c6f31583db7731df949a31b3">drawVertices</a> (<a class="el" href="class_sk_canvas.html#a9ec1e6851be5e6aaa7cab9797822ed58">VertexMode</a> vmode, int vertexCount, const <a class="el" href="struct_sk_point.html">SkPoint</a> vertices[], const <a class="el" href="struct_sk_point.html">SkPoint</a> texs[], const <a class="el" href="_sk_color_8h.html#a84c81e6a24ff07a55333acf5603046a8">SkColor</a> colors[], <a class="el" href="class_sk_xfermode.html">SkXfermode</a> *xmode, const uint16_t indices[], int indexCount, const <a class="el" href="class_sk_paint.html">SkPaint</a> &amp;paint)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_sk_bounder.html">SkBounder</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_proxy_canvas.html#a50e73c8be7e8e3aab098dcf7dc2c8529">setBounder</a> (<a class="el" href="class_sk_bounder.html">SkBounder</a> *bounder)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_sk_draw_filter.html">SkDrawFilter</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_proxy_canvas.html#ab73f72960f0019f6a25df0c60020826f">setDrawFilter</a> (<a class="el" href="class_sk_draw_filter.html">SkDrawFilter</a> *filter)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_sk_device.html">SkDevice</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_proxy_canvas.html#a1a185f065de54ad32ab48eaac5f3f386">createDevice</a> (<a class="el" href="class_sk_bitmap.html#a62602e28fc755def34d7e261bfd0b74a">SkBitmap::Config</a>, int width, int height, bool isOpaque, bool isForLayer)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>This class overrides all virtual methods on <a class="el" href="class_sk_canvas.html">SkCanvas</a>, and redirects them to a "proxy", another <a class="el" href="class_sk_canvas.html">SkCanvas</a> instance. It can be the basis for intercepting (and possibly modifying) calls to a canvas.</p>
<p>There must be a proxy installed before the proxycanvas can be used (i.e. before its virtual methods can be called). </p>

<p>Definition at line <a class="el" href="_sk_proxy_canvas_8h_source.html#l00013">13</a> of file <a class="el" href="_sk_proxy_canvas_8h_source.html">SkProxyCanvas.h</a>.</p>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a29444b8a946993196d9a608f6f3b0269"></a><!-- doxytag: member="SkProxyCanvas::SkProxyCanvas" ref="a29444b8a946993196d9a608f6f3b0269" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SkProxyCanvas::SkProxyCanvas </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_sk_proxy_canvas_8h_source.html#l00015">15</a> of file <a class="el" href="_sk_proxy_canvas_8h_source.html">SkProxyCanvas.h</a>.</p>

</div>
</div>
<a class="anchor" id="a2aedda8ab874267f5517a0aa711d12a3"></a><!-- doxytag: member="SkProxyCanvas::SkProxyCanvas" ref="a2aedda8ab874267f5517a0aa711d12a3" args="(SkCanvas *proxy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SkProxyCanvas::SkProxyCanvas </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_sk_canvas.html">SkCanvas</a> *&nbsp;</td>
          <td class="paramname"> <em>proxy</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a25128b790196fb7d77a36289ad3d4d69"></a><!-- doxytag: member="SkProxyCanvas::~SkProxyCanvas" ref="a25128b790196fb7d77a36289ad3d4d69" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual SkProxyCanvas::~SkProxyCanvas </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="aaa37f01fd077adf3a0d3a28ae8448078"></a><!-- doxytag: member="SkProxyCanvas::clipPath" ref="aaa37f01fd077adf3a0d3a28ae8448078" args="(const SkPath &amp;path, SkRegion::Op op=SkRegion::kIntersect_Op)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool SkProxyCanvas::clipPath </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sk_path.html">SkPath</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_sk_region.html#a2ced93c36095d876b020e20cf39f5b54">SkRegion::Op</a>&nbsp;</td>
          <td class="paramname"> <em>op</em> = <code>SkRegion::kIntersect_Op</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Modify the current clip with the specified path. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>path</em>&nbsp;</td><td>The path to apply to the current clip </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>op</em>&nbsp;</td><td>The region op to apply to the current clip </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the canvas' new clip is non-empty </dd></dl>

<p>Reimplemented from <a class="el" href="class_sk_canvas.html#a8f02d433448c14d01dddae6ecf563600">SkCanvas</a>.</p>

</div>
</div>
<a class="anchor" id="a003658103e75cb322a4ed6459a9fb7da"></a><!-- doxytag: member="SkProxyCanvas::clipRect" ref="a003658103e75cb322a4ed6459a9fb7da" args="(const SkRect &amp;rect, SkRegion::Op op=SkRegion::kIntersect_Op)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool SkProxyCanvas::clipRect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_sk_rect.html">SkRect</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>rect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_sk_region.html#a2ced93c36095d876b020e20cf39f5b54">SkRegion::Op</a>&nbsp;</td>
          <td class="paramname"> <em>op</em> = <code>SkRegion::kIntersect_Op</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Modify the current clip with the specified rectangle. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rect</em>&nbsp;</td><td>The rect to intersect with the current clip </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>op</em>&nbsp;</td><td>The region op to apply to the current clip </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the canvas' clip is non-empty </dd></dl>

<p>Reimplemented from <a class="el" href="class_sk_canvas.html#a963d2eef31e9a22e45b7a9f0020d57b1">SkCanvas</a>.</p>

</div>
</div>
<a class="anchor" id="a3453740ab70feb3f3b3d2ceb1476a959"></a><!-- doxytag: member="SkProxyCanvas::clipRegion" ref="a3453740ab70feb3f3b3d2ceb1476a959" args="(const SkRegion &amp;deviceRgn, SkRegion::Op op=SkRegion::kIntersect_Op)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool SkProxyCanvas::clipRegion </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sk_region.html">SkRegion</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>deviceRgn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_sk_region.html#a2ced93c36095d876b020e20cf39f5b54">SkRegion::Op</a>&nbsp;</td>
          <td class="paramname"> <em>op</em> = <code>SkRegion::kIntersect_Op</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Modify the current clip with the specified region. Note that unlike <a class="el" href="class_sk_proxy_canvas.html#a003658103e75cb322a4ed6459a9fb7da">clipRect()</a> and <a class="el" href="class_sk_proxy_canvas.html#aaa37f01fd077adf3a0d3a28ae8448078">clipPath()</a> which transform their arguments by the current matrix, <a class="el" href="class_sk_proxy_canvas.html#a3453740ab70feb3f3b3d2ceb1476a959">clipRegion()</a> assumes its argument is already in device coordinates, and so no transformation is performed. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>deviceRgn</em>&nbsp;</td><td>The region to apply to the current clip </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>op</em>&nbsp;</td><td>The region op to apply to the current clip </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the canvas' new clip is non-empty </dd></dl>

<p>Reimplemented from <a class="el" href="class_sk_canvas.html#ad6981b92e554398887cab39f67a529cc">SkCanvas</a>.</p>

</div>
</div>
<a class="anchor" id="a2216920751c7f58c80791b1e81365c18"></a><!-- doxytag: member="SkProxyCanvas::concat" ref="a2216920751c7f58c80791b1e81365c18" args="(const SkMatrix &amp;matrix)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool SkProxyCanvas::concat </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sk_matrix.html">SkMatrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>matrix</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Preconcat the current matrix with the specified matrix. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>matrix</em>&nbsp;</td><td>The matrix to preconcatenate with the current matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the operation succeeded (e.g. did not overflow) </dd></dl>

<p>Reimplemented from <a class="el" href="class_sk_canvas.html#a2a2f5317b3bd454055df4d9c83b9b5cf">SkCanvas</a>.</p>

</div>
</div>
<a class="anchor" id="a1a185f065de54ad32ab48eaac5f3f386"></a><!-- doxytag: member="SkProxyCanvas::createDevice" ref="a1a185f065de54ad32ab48eaac5f3f386" args="(SkBitmap::Config, int width, int height, bool isOpaque, bool isForLayer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_sk_device.html">SkDevice</a>* SkProxyCanvas::createDevice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_sk_bitmap.html#a62602e28fc755def34d7e261bfd0b74a">SkBitmap::Config</a>&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>isOpaque</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>isForLayer</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>May be overridden by subclasses. This returns a compatible device for this canvas, with the specified config/width/height. If isOpaque is true, then the underlying bitmap is optimized to assume that every pixel will be drawn to, and thus it does not need to clear the alpha channel ahead of time (assuming the specified config supports per-pixel alpha.) If isOpaque is false, then the bitmap should clear its alpha channel. </p>

<p>Reimplemented from <a class="el" href="class_sk_canvas.html#ad9a7eb604feaf007bcfacff32d6ee91e">SkCanvas</a>.</p>

</div>
</div>
<a class="anchor" id="a9fb3db90b6da815509d5ac453a56e1a1"></a><!-- doxytag: member="SkProxyCanvas::drawBitmap" ref="a9fb3db90b6da815509d5ac453a56e1a1" args="(const SkBitmap &amp;bitmap, SkScalar left, SkScalar top, const SkPaint *paint=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SkProxyCanvas::drawBitmap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sk_bitmap.html">SkBitmap</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>bitmap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_sk_scalar_8h.html#a407e363d56d824ed93bd6d1fda2effcf">SkScalar</a>&nbsp;</td>
          <td class="paramname"> <em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_sk_scalar_8h.html#a407e363d56d824ed93bd6d1fda2effcf">SkScalar</a>&nbsp;</td>
          <td class="paramname"> <em>top</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_sk_paint.html">SkPaint</a> *&nbsp;</td>
          <td class="paramname"> <em>paint</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Draw the specified bitmap, with its top/left corner at (x,y), using the specified paint, transformed by the current matrix. Note: if the paint contains a maskfilter that generates a mask which extends beyond the bitmap's original width/height, then the bitmap will be drawn as if it were in a Shader with CLAMP mode. Thus the color outside of the original width/height will be the edge color replicated. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>bitmap</em>&nbsp;</td><td>The bitmap to be drawn </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>left</em>&nbsp;</td><td>The position of the left side of the bitmap being drawn </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>top</em>&nbsp;</td><td>The position of the top side of the bitmap being drawn </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>paint</em>&nbsp;</td><td>The paint used to draw the bitmap, or NULL </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_sk_canvas.html#a17c2d2bd41041981ac8706905d654f47">SkCanvas</a>.</p>

</div>
</div>
<a class="anchor" id="a2e82ee879d8d347e196115b11c7baf08"></a><!-- doxytag: member="SkProxyCanvas::drawBitmapMatrix" ref="a2e82ee879d8d347e196115b11c7baf08" args="(const SkBitmap &amp;bitmap, const SkMatrix &amp;m, const SkPaint *paint=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SkProxyCanvas::drawBitmapMatrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sk_bitmap.html">SkBitmap</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>bitmap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_sk_matrix.html">SkMatrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_sk_paint.html">SkPaint</a> *&nbsp;</td>
          <td class="paramname"> <em>paint</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="class_sk_canvas.html#a448beaa4b046808e540d1492c40e3566">SkCanvas</a>.</p>

</div>
</div>
<a class="anchor" id="aab18deeef885832f73e50056af6826d1"></a><!-- doxytag: member="SkProxyCanvas::drawBitmapRect" ref="aab18deeef885832f73e50056af6826d1" args="(const SkBitmap &amp;bitmap, const SkIRect *src, const SkRect &amp;dst, const SkPaint *paint=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SkProxyCanvas::drawBitmapRect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sk_bitmap.html">SkBitmap</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>bitmap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_sk_i_rect.html">SkIRect</a> *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_sk_rect.html">SkRect</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_sk_paint.html">SkPaint</a> *&nbsp;</td>
          <td class="paramname"> <em>paint</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Draw the specified bitmap, with the specified matrix applied (before the canvas' matrix is applied). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>bitmap</em>&nbsp;</td><td>The bitmap to be drawn </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>Optional: specify the subset of the bitmap to be drawn </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dst</em>&nbsp;</td><td>The destination rectangle where the scaled/translated image will be drawn </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>paint</em>&nbsp;</td><td>The paint used to draw the bitmap, or NULL </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_sk_canvas.html#a2521b2f7fe8449e30e286878fec98140">SkCanvas</a>.</p>

</div>
</div>
<a class="anchor" id="a13ca3fabc375d1e0cdb11d2a89e89ba4"></a><!-- doxytag: member="SkProxyCanvas::drawPaint" ref="a13ca3fabc375d1e0cdb11d2a89e89ba4" args="(const SkPaint &amp;paint)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SkProxyCanvas::drawPaint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sk_paint.html">SkPaint</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>paint</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Fill the entire canvas' bitmap (restricted to the current clip) with the specified paint. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>paint</em>&nbsp;</td><td>The paint used to fill the canvas </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_sk_canvas.html#a68d5e7d505eb881967a9988c75ef4f17">SkCanvas</a>.</p>

</div>
</div>
<a class="anchor" id="a8918e8cd9535dc5b464e9f69261c6918"></a><!-- doxytag: member="SkProxyCanvas::drawPath" ref="a8918e8cd9535dc5b464e9f69261c6918" args="(const SkPath &amp;path, const SkPaint &amp;paint)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SkProxyCanvas::drawPath </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sk_path.html">SkPath</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_sk_paint.html">SkPaint</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>paint</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Draw the specified path using the specified paint. The path will be filled or framed based on the Style in the paint. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>path</em>&nbsp;</td><td>The path to be drawn </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>paint</em>&nbsp;</td><td>The paint used to draw the path </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_sk_canvas.html#a19f1497279f355c61cfdd3686c0e90a3">SkCanvas</a>.</p>

</div>
</div>
<a class="anchor" id="af80b45954f57f0c8167e43262aa089c9"></a><!-- doxytag: member="SkProxyCanvas::drawPicture" ref="af80b45954f57f0c8167e43262aa089c9" args="(SkPicture &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SkProxyCanvas::drawPicture </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_sk_picture.html">SkPicture</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>picture</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Draw the picture into this canvas. This method effective brackets the playback of the picture's draw calls with save/restore, so the state of this canvas will be unchanged after this call. This contrasts with the more immediate method <a class="el" href="class_sk_picture.html#adf1b69943f6927166c6a55f3b32ee034">SkPicture::draw()</a>, which does not bracket the canvas with save/restore, thus the canvas may be left in a changed state after the call. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>picture</em>&nbsp;</td><td>The recorded drawing commands to playback into this canvas. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_sk_canvas.html#a2fa024453629da8f45e12f4d6fe5b012">SkCanvas</a>.</p>

</div>
</div>
<a class="anchor" id="a4b9dba4a0b4822f677d8d658b836cb15"></a><!-- doxytag: member="SkProxyCanvas::drawPoints" ref="a4b9dba4a0b4822f677d8d658b836cb15" args="(PointMode mode, size_t count, const SkPoint pts[], const SkPaint &amp;paint)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SkProxyCanvas::drawPoints </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_sk_canvas.html#af1bcd412326a6886e0f260d4d2dc757b">PointMode</a>&nbsp;</td>
          <td class="paramname"> <em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_sk_point.html">SkPoint</a>&nbsp;</td>
          <td class="paramname"> <em>pts</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_sk_paint.html">SkPaint</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>paint</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Draw a series of points, interpreted based on the PointMode mode. For all modes, the count parameter is interpreted as the total number of points. For kLine mode, count/2 line segments are drawn. For kPoint mode, each point is drawn centered at its coordinate, and its size is specified by the paint's stroke-width. It draws as a square, unless the paint's cap-type is round, in which the points are drawn as circles. For kLine mode, each pair of points is drawn as a line segment, respecting the paint's settings for cap/join/width. For kPolygon mode, the entire array is drawn as a series of connected line segments. Note that, while similar, kLine and kPolygon modes draw slightly differently than the equivalent path built with a series of moveto, lineto calls, in that the path will draw all of its contours at once, with no interactions if contours intersect each other (think XOR xfermode). drawPoints always draws each element one at a time. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mode</em>&nbsp;</td><td>PointMode specifying how to draw the array of points. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>The number of points in the array </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pts</em>&nbsp;</td><td>Array of points to draw </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>paint</em>&nbsp;</td><td>The paint used to draw the points </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_sk_canvas.html#ac3018677c5277dd2e1d31183d41f3297">SkCanvas</a>.</p>

</div>
</div>
<a class="anchor" id="ab87a00cb9ec1210c85e9acaa772dae52"></a><!-- doxytag: member="SkProxyCanvas::drawPosText" ref="ab87a00cb9ec1210c85e9acaa772dae52" args="(const void *text, size_t byteLength, const SkPoint pos[], const SkPaint &amp;paint)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SkProxyCanvas::drawPosText </td>
          <td>(</td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>byteLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_sk_point.html">SkPoint</a>&nbsp;</td>
          <td class="paramname"> <em>pos</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_sk_paint.html">SkPaint</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>paint</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Draw the text, with each character/glyph origin specified by the pos[] array. The origin is interpreted by the Align setting in the paint. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>text</em>&nbsp;</td><td>The text to be drawn </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>byteLength</em>&nbsp;</td><td>The number of bytes to read from the text parameter </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pos</em>&nbsp;</td><td>Array of positions, used to position each character </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>paint</em>&nbsp;</td><td>The paint used for the text (e.g. color, size, style) </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_sk_canvas.html#a5cafeedbbaf1f8dbf1b3947e6a7dc889">SkCanvas</a>.</p>

</div>
</div>
<a class="anchor" id="ac5bfca39aadc8144354e318379f74902"></a><!-- doxytag: member="SkProxyCanvas::drawPosTextH" ref="ac5bfca39aadc8144354e318379f74902" args="(const void *text, size_t byteLength, const SkScalar xpos[], SkScalar constY, const SkPaint &amp;paint)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SkProxyCanvas::drawPosTextH </td>
          <td>(</td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>byteLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_sk_scalar_8h.html#a407e363d56d824ed93bd6d1fda2effcf">SkScalar</a>&nbsp;</td>
          <td class="paramname"> <em>xpos</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_sk_scalar_8h.html#a407e363d56d824ed93bd6d1fda2effcf">SkScalar</a>&nbsp;</td>
          <td class="paramname"> <em>constY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_sk_paint.html">SkPaint</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>paint</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Draw the text, with each character/glyph origin specified by the x coordinate taken from the xpos[] array, and the y from the constY param. The origin is interpreted by the Align setting in the paint. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>text</em>&nbsp;</td><td>The text to be drawn </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>byteLength</em>&nbsp;</td><td>The number of bytes to read from the text parameter </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>xpos</em>&nbsp;</td><td>Array of x-positions, used to position each character </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>constY</em>&nbsp;</td><td>The shared Y coordinate for all of the positions </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>paint</em>&nbsp;</td><td>The paint used for the text (e.g. color, size, style) </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_sk_canvas.html#add609f47110f6109ad5e25868ab30efc">SkCanvas</a>.</p>

</div>
</div>
<a class="anchor" id="a5b8d732709f01d37fa8e5180c8d877dc"></a><!-- doxytag: member="SkProxyCanvas::drawRect" ref="a5b8d732709f01d37fa8e5180c8d877dc" args="(const SkRect &amp;rect, const SkPaint &amp;paint)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SkProxyCanvas::drawRect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_sk_rect.html">SkRect</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>rect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_sk_paint.html">SkPaint</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>paint</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Draw the specified rectangle using the specified paint. The rectangle will be filled or stroked based on the Style in the paint. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rect</em>&nbsp;</td><td>The rect to be drawn </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>paint</em>&nbsp;</td><td>The paint used to draw the rect </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_sk_canvas.html#a3bf4d3ff9e3bada28acc7423fffacfc5">SkCanvas</a>.</p>

</div>
</div>
<a class="anchor" id="a4939b793160552abef82098978eb4081"></a><!-- doxytag: member="SkProxyCanvas::drawShape" ref="a4939b793160552abef82098978eb4081" args="(SkShape *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SkProxyCanvas::drawShape </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_sk_shape.html">SkShape</a> *&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Draws the specified shape </p>

<p>Reimplemented from <a class="el" href="class_sk_canvas.html#a81006b6af71fabc802e11ea9277be3cf">SkCanvas</a>.</p>

</div>
</div>
<a class="anchor" id="a3f05a6956390d4d0b76546aa24ab988a"></a><!-- doxytag: member="SkProxyCanvas::drawSprite" ref="a3f05a6956390d4d0b76546aa24ab988a" args="(const SkBitmap &amp;bitmap, int left, int top, const SkPaint *paint=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SkProxyCanvas::drawSprite </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sk_bitmap.html">SkBitmap</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>bitmap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>top</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_sk_paint.html">SkPaint</a> *&nbsp;</td>
          <td class="paramname"> <em>paint</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Draw the specified bitmap, with its top/left corner at (x,y), NOT transformed by the current matrix. Note: if the paint contains a maskfilter that generates a mask which extends beyond the bitmap's original width/height, then the bitmap will be drawn as if it were in a Shader with CLAMP mode. Thus the color outside of the original width/height will be the edge color replicated. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>bitmap</em>&nbsp;</td><td>The bitmap to be drawn </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>left</em>&nbsp;</td><td>The position of the left side of the bitmap being drawn </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>top</em>&nbsp;</td><td>The position of the top side of the bitmap being drawn </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>paint</em>&nbsp;</td><td>The paint used to draw the bitmap, or NULL </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_sk_canvas.html#a4385c5584a1fe8777a9974b607bf72ee">SkCanvas</a>.</p>

</div>
</div>
<a class="anchor" id="aa4a4886ab97dca0ac689fa9b1850bbf9"></a><!-- doxytag: member="SkProxyCanvas::drawText" ref="aa4a4886ab97dca0ac689fa9b1850bbf9" args="(const void *text, size_t byteLength, SkScalar x, SkScalar y, const SkPaint &amp;paint)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SkProxyCanvas::drawText </td>
          <td>(</td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>byteLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_sk_scalar_8h.html#a407e363d56d824ed93bd6d1fda2effcf">SkScalar</a>&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_sk_scalar_8h.html#a407e363d56d824ed93bd6d1fda2effcf">SkScalar</a>&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_sk_paint.html">SkPaint</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>paint</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Draw the text, with origin at (x,y), using the specified paint. The origin is interpreted based on the Align setting in the paint. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>text</em>&nbsp;</td><td>The text to be drawn </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>byteLength</em>&nbsp;</td><td>The number of bytes to read from the text parameter </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>The x-coordinate of the origin of the text being drawn </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>y</em>&nbsp;</td><td>The y-coordinate of the origin of the text being drawn </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>paint</em>&nbsp;</td><td>The paint used for the text (e.g. color, size, style) </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_sk_canvas.html#a6abc9c64496983ebee287cfcf3a3d33f">SkCanvas</a>.</p>

</div>
</div>
<a class="anchor" id="a35fb9745a41680ce65e16e9c01d2891c"></a><!-- doxytag: member="SkProxyCanvas::drawTextOnPath" ref="a35fb9745a41680ce65e16e9c01d2891c" args="(const void *text, size_t byteLength, const SkPath &amp;path, const SkMatrix *matrix, const SkPaint &amp;paint)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SkProxyCanvas::drawTextOnPath </td>
          <td>(</td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>byteLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_sk_path.html">SkPath</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_sk_matrix.html">SkMatrix</a> *&nbsp;</td>
          <td class="paramname"> <em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_sk_paint.html">SkPaint</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>paint</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Draw the text, with origin at (x,y), using the specified paint, along the specified path. The paint's Align setting determins where along the path to start the text. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>text</em>&nbsp;</td><td>The text to be drawn </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>byteLength</em>&nbsp;</td><td>The number of bytes to read from the text parameter </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>path</em>&nbsp;</td><td>The path the text should follow for its baseline </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>matrix</em>&nbsp;</td><td>(may be null) Applied to the text before it is mapped onto the path </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>paint</em>&nbsp;</td><td>The paint used for the text </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_sk_canvas.html#ad48875ca22ddc69bf90164cddb960049">SkCanvas</a>.</p>

</div>
</div>
<a class="anchor" id="af31d9276c6f31583db7731df949a31b3"></a><!-- doxytag: member="SkProxyCanvas::drawVertices" ref="af31d9276c6f31583db7731df949a31b3" args="(VertexMode vmode, int vertexCount, const SkPoint vertices[], const SkPoint texs[], const SkColor colors[], SkXfermode *xmode, const uint16_t indices[], int indexCount, const SkPaint &amp;paint)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SkProxyCanvas::drawVertices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_sk_canvas.html#a9ec1e6851be5e6aaa7cab9797822ed58">VertexMode</a>&nbsp;</td>
          <td class="paramname"> <em>vmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>vertexCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_sk_point.html">SkPoint</a>&nbsp;</td>
          <td class="paramname"> <em>vertices</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_sk_point.html">SkPoint</a>&nbsp;</td>
          <td class="paramname"> <em>texs</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_sk_color_8h.html#a84c81e6a24ff07a55333acf5603046a8">SkColor</a>&nbsp;</td>
          <td class="paramname"> <em>colors</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_sk_xfermode.html">SkXfermode</a> *&nbsp;</td>
          <td class="paramname"> <em>xmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&nbsp;</td>
          <td class="paramname"> <em>indices</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>indexCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_sk_paint.html">SkPaint</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>paint</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Draw the array of vertices, interpreted as triangles (based on mode). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vmode</em>&nbsp;</td><td>How to interpret the array of vertices </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vertexCount</em>&nbsp;</td><td>The number of points in the vertices array (and corresponding texs and colors arrays if non-null) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vertices</em>&nbsp;</td><td>Array of vertices for the mesh </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>texs</em>&nbsp;</td><td>May be null. If not null, specifies the coordinate in texture space for each vertex. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>colors</em>&nbsp;</td><td>May be null. If not null, specifies a color for each vertex, to be interpolated across the triangle. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>xmode</em>&nbsp;</td><td>Used if both texs and colors are present. In this case the colors are combined with the texture using mode, before being drawn using the paint. If mode is null, then kMultiply_Mode is used. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>indices</em>&nbsp;</td><td>If not null, array of indices to reference into the vertex (texs, colors) array. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>indexCount</em>&nbsp;</td><td>number of entries in the indices array (if not null) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>paint</em>&nbsp;</td><td>Specifies the shader/texture if present. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_sk_canvas.html#a93a9df6e7ec7aa2f0b4ccc412267654f">SkCanvas</a>.</p>

</div>
</div>
<a class="anchor" id="a90df240f9130ebdef3236a50a8e7064b"></a><!-- doxytag: member="SkProxyCanvas::getProxy" ref="a90df240f9130ebdef3236a50a8e7064b" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sk_canvas.html">SkCanvas</a>* SkProxyCanvas::getProxy </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_sk_proxy_canvas_8h_source.html#l00019">19</a> of file <a class="el" href="_sk_proxy_canvas_8h_source.html">SkProxyCanvas.h</a>.</p>

</div>
</div>
<a class="anchor" id="a32ee2a6b6ef25981da317be01e678723"></a><!-- doxytag: member="SkProxyCanvas::getViewport" ref="a32ee2a6b6ef25981da317be01e678723" args="(SkIPoint *size) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool SkProxyCanvas::getViewport </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_sk_i_point.html">SkIPoint</a> *&nbsp;</td>
          <td class="paramname"> <em>size</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>If this subclass of <a class="el" href="class_sk_canvas.html">SkCanvas</a> supports GL viewports, return true and set size (if not null) to the size of the viewport. If it is not supported, ignore vp and return false. </p>

<p>Reimplemented from <a class="el" href="class_sk_canvas.html#ae7a16c11d4bb28ead36107671393e12d">SkCanvas</a>.</p>

</div>
</div>
<a class="anchor" id="ac9b75e31170ca5506aeeca1bc2697a6d"></a><!-- doxytag: member="SkProxyCanvas::restore" ref="ac9b75e31170ca5506aeeca1bc2697a6d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SkProxyCanvas::restore </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This call balances a previous call to <a class="el" href="class_sk_proxy_canvas.html#a58b8be5e635d770f00ef137b659833a4">save()</a>, and is used to remove all modifications to the matrix/clip state since the last save call. It is an error to call <a class="el" href="class_sk_proxy_canvas.html#ac9b75e31170ca5506aeeca1bc2697a6d">restore()</a> more times than <a class="el" href="class_sk_proxy_canvas.html#a58b8be5e635d770f00ef137b659833a4">save()</a> was called. </p>

<p>Reimplemented from <a class="el" href="class_sk_canvas.html#ae84eb888885e73f152deb0ff65ee1183">SkCanvas</a>.</p>

</div>
</div>
<a class="anchor" id="a221a3f017f8433479a0553e69e057df0"></a><!-- doxytag: member="SkProxyCanvas::rotate" ref="a221a3f017f8433479a0553e69e057df0" args="(SkScalar degrees)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool SkProxyCanvas::rotate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_sk_scalar_8h.html#a407e363d56d824ed93bd6d1fda2effcf">SkScalar</a>&nbsp;</td>
          <td class="paramname"> <em>degrees</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Preconcat the current matrix with the specified rotation. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>degrees</em>&nbsp;</td><td>The amount to rotate, in degrees returns true if the operation succeeded (e.g. did not overflow) </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_sk_canvas.html#ae7954bcc3ce7da3ba845dfa4f573cf57">SkCanvas</a>.</p>

</div>
</div>
<a class="anchor" id="a58b8be5e635d770f00ef137b659833a4"></a><!-- doxytag: member="SkProxyCanvas::save" ref="a58b8be5e635d770f00ef137b659833a4" args="(SaveFlags flags=kMatrixClip_SaveFlag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int SkProxyCanvas::save </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_sk_canvas.html#a438a1ae606d773f95054f1df6ff2bdf2">SaveFlags</a>&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>kMatrixClip_SaveFlag</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This call saves the current matrix and clip information, and pushes a copy onto a private stack. Subsequent calls to translate, scale, rotate, skew, concat or clipRect, clipPath all operate on this copy. When the balancing call to <a class="el" href="class_sk_proxy_canvas.html#ac9b75e31170ca5506aeeca1bc2697a6d">restore()</a> is made, this copy is deleted and the previous matrix/clip state is restored. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The value to pass to <a class="el" href="class_sk_canvas.html#aae519c51173be795b59f4f4e10c67b9d">restoreToCount()</a> to balance this <a class="el" href="class_sk_proxy_canvas.html#a58b8be5e635d770f00ef137b659833a4">save()</a> </dd></dl>

<p>Reimplemented from <a class="el" href="class_sk_canvas.html#a19a04ec8b7f13043fbbf14355413af9f">SkCanvas</a>.</p>

</div>
</div>
<a class="anchor" id="ae5c7919420c9ffbe737010dbc2213245"></a><!-- doxytag: member="SkProxyCanvas::saveLayer" ref="ae5c7919420c9ffbe737010dbc2213245" args="(const SkRect *bounds, const SkPaint *paint, SaveFlags flags=kARGB_ClipLayer_SaveFlag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int SkProxyCanvas::saveLayer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_sk_rect.html">SkRect</a> *&nbsp;</td>
          <td class="paramname"> <em>bounds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_sk_paint.html">SkPaint</a> *&nbsp;</td>
          <td class="paramname"> <em>paint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_sk_canvas.html#a438a1ae606d773f95054f1df6ff2bdf2">SaveFlags</a>&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>kARGB_ClipLayer_SaveFlag</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This behaves the same as <a class="el" href="class_sk_proxy_canvas.html#a58b8be5e635d770f00ef137b659833a4">save()</a>, but in addition it allocates an offscreen bitmap. All drawing calls are directed there, and only when the balancing call to <a class="el" href="class_sk_proxy_canvas.html#ac9b75e31170ca5506aeeca1bc2697a6d">restore()</a> is made is that offscreen transfered to the canvas (or the previous layer). Subsequent calls to translate, scale, rotate, skew, concat or clipRect, clipPath all operate on this copy. When the balancing call to <a class="el" href="class_sk_proxy_canvas.html#ac9b75e31170ca5506aeeca1bc2697a6d">restore()</a> is made, this copy is deleted and the previous matrix/clip state is restored. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>bounds</em>&nbsp;</td><td>(may be null) the maximum size the offscreen bitmap needs to be (in local coordinates) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>paint</em>&nbsp;</td><td>(may be null) This is copied, and is applied to the offscreen when <a class="el" href="class_sk_proxy_canvas.html#ac9b75e31170ca5506aeeca1bc2697a6d">restore()</a> is called </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>LayerFlags </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The value to pass to <a class="el" href="class_sk_canvas.html#aae519c51173be795b59f4f4e10c67b9d">restoreToCount()</a> to balance this <a class="el" href="class_sk_proxy_canvas.html#a58b8be5e635d770f00ef137b659833a4">save()</a> </dd></dl>

<p>Reimplemented from <a class="el" href="class_sk_canvas.html#ae0782e23cbcc6bb10e015a2bf1f5958a">SkCanvas</a>.</p>

</div>
</div>
<a class="anchor" id="adc1ee09cc90b9e9cddf856fd15265dca"></a><!-- doxytag: member="SkProxyCanvas::scale" ref="adc1ee09cc90b9e9cddf856fd15265dca" args="(SkScalar sx, SkScalar sy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool SkProxyCanvas::scale </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_sk_scalar_8h.html#a407e363d56d824ed93bd6d1fda2effcf">SkScalar</a>&nbsp;</td>
          <td class="paramname"> <em>sx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_sk_scalar_8h.html#a407e363d56d824ed93bd6d1fda2effcf">SkScalar</a>&nbsp;</td>
          <td class="paramname"> <em>sy</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Preconcat the current matrix with the specified scale. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sx</em>&nbsp;</td><td>The amount to scale in X </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sy</em>&nbsp;</td><td>The amount to scale in Y returns true if the operation succeeded (e.g. did not overflow) </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_sk_canvas.html#a0adadc0c50cc8cf4dec80a5e450a6c3c">SkCanvas</a>.</p>

</div>
</div>
<a class="anchor" id="aefeaaf9aba80b029adc658f1c920b2e1"></a><!-- doxytag: member="SkProxyCanvas::setBitmapDevice" ref="aefeaaf9aba80b029adc658f1c920b2e1" args="(const SkBitmap &amp;bitmap)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_sk_device.html">SkDevice</a>* SkProxyCanvas::setBitmapDevice </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sk_bitmap.html">SkBitmap</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>bitmap</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Specify a bitmap for the canvas to draw into. This is a help method for <a class="el" href="class_sk_canvas.html#a9f4c51cdbb30cb193dbb0f17d706a6fc">setDevice()</a>, and it creates a device for the bitmap by calling <a class="el" href="class_sk_proxy_canvas.html#a1a185f065de54ad32ab48eaac5f3f386">createDevice()</a>. The structure of the bitmap is copied into the device. </p>

<p>Reimplemented from <a class="el" href="class_sk_canvas.html#a30e49a6e6274341a4474f58c400315e2">SkCanvas</a>.</p>

</div>
</div>
<a class="anchor" id="a50e73c8be7e8e3aab098dcf7dc2c8529"></a><!-- doxytag: member="SkProxyCanvas::setBounder" ref="a50e73c8be7e8e3aab098dcf7dc2c8529" args="(SkBounder *bounder)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_sk_bounder.html">SkBounder</a>* SkProxyCanvas::setBounder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_sk_bounder.html">SkBounder</a> *&nbsp;</td>
          <td class="paramname"> <em>bounder</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set a new bounder (or NULL). Pass NULL to clear any previous bounder. As a convenience, the parameter passed is also returned. If a previous bounder exists, its reference count is decremented. If bounder is not NULL, its reference count is incremented. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>bounder</em>&nbsp;</td><td>the new bounder (or NULL) to be installed in the canvas </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the set bounder object </dd></dl>

<p>Reimplemented from <a class="el" href="class_sk_canvas.html#a717b592a7f796556b314947b8ce87de0">SkCanvas</a>.</p>

</div>
</div>
<a class="anchor" id="ab73f72960f0019f6a25df0c60020826f"></a><!-- doxytag: member="SkProxyCanvas::setDrawFilter" ref="ab73f72960f0019f6a25df0c60020826f" args="(SkDrawFilter *filter)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_sk_draw_filter.html">SkDrawFilter</a>* SkProxyCanvas::setDrawFilter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_sk_draw_filter.html">SkDrawFilter</a> *&nbsp;</td>
          <td class="paramname"> <em>filter</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the new filter (or NULL). Pass NULL to clear any existing filter. As a convenience, the parameter is returned. If an existing filter exists, its refcnt is decrement. If the new filter is not null, its refcnt is incremented. The filter is part of the state this is affected by save/restore. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>filter</em>&nbsp;</td><td>the new filter (or NULL) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the new filter </dd></dl>

<p>Reimplemented from <a class="el" href="class_sk_canvas.html#aff4b429d65d4cc621013c7b6f8248004">SkCanvas</a>.</p>

</div>
</div>
<a class="anchor" id="ae65434deb607a05f68dc5a11ce4ccc71"></a><!-- doxytag: member="SkProxyCanvas::setMatrix" ref="ae65434deb607a05f68dc5a11ce4ccc71" args="(const SkMatrix &amp;matrix)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SkProxyCanvas::setMatrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sk_matrix.html">SkMatrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>matrix</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Replace the current matrix with a copy of the specified matrix. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>matrix</em>&nbsp;</td><td>The matrix that will be copied into the current matrix. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_sk_canvas.html#a56ee2bfea2934447dcc573489f55d2bf">SkCanvas</a>.</p>

</div>
</div>
<a class="anchor" id="a52c7f56652deb3357a599c449aa48ca6"></a><!-- doxytag: member="SkProxyCanvas::setProxy" ref="a52c7f56652deb3357a599c449aa48ca6" args="(SkCanvas *proxy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SkProxyCanvas::setProxy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_sk_canvas.html">SkCanvas</a> *&nbsp;</td>
          <td class="paramname"> <em>proxy</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a850d8cb87972a7eef443e82f969b4147"></a><!-- doxytag: member="SkProxyCanvas::setViewport" ref="a850d8cb87972a7eef443e82f969b4147" args="(int x, int y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool SkProxyCanvas::setViewport </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>y</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>If this subclass of <a class="el" href="class_sk_canvas.html">SkCanvas</a> supports GL viewports, return true and set the viewport to the specified x and y dimensions. If it is not supported, ignore x and y and return false. </p>

<p>Reimplemented from <a class="el" href="class_sk_canvas.html#a2cbf69015d032a4118dfe0f85c1aed5d">SkCanvas</a>.</p>

</div>
</div>
<a class="anchor" id="a942460e35e38f19bfc603e19d49597ff"></a><!-- doxytag: member="SkProxyCanvas::skew" ref="a942460e35e38f19bfc603e19d49597ff" args="(SkScalar sx, SkScalar sy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool SkProxyCanvas::skew </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_sk_scalar_8h.html#a407e363d56d824ed93bd6d1fda2effcf">SkScalar</a>&nbsp;</td>
          <td class="paramname"> <em>sx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_sk_scalar_8h.html#a407e363d56d824ed93bd6d1fda2effcf">SkScalar</a>&nbsp;</td>
          <td class="paramname"> <em>sy</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Preconcat the current matrix with the specified skew. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sx</em>&nbsp;</td><td>The amount to skew in X </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sy</em>&nbsp;</td><td>The amount to skew in Y returns true if the operation succeeded (e.g. did not overflow) </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_sk_canvas.html#a6b33c84811bee5758d57a63a66476c04">SkCanvas</a>.</p>

</div>
</div>
<a class="anchor" id="ab8241fc4f0904fc554f6b210da62031a"></a><!-- doxytag: member="SkProxyCanvas::translate" ref="ab8241fc4f0904fc554f6b210da62031a" args="(SkScalar dx, SkScalar dy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool SkProxyCanvas::translate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_sk_scalar_8h.html#a407e363d56d824ed93bd6d1fda2effcf">SkScalar</a>&nbsp;</td>
          <td class="paramname"> <em>dx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_sk_scalar_8h.html#a407e363d56d824ed93bd6d1fda2effcf">SkScalar</a>&nbsp;</td>
          <td class="paramname"> <em>dy</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Preconcat the current matrix with the specified translation </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dx</em>&nbsp;</td><td>The distance to translate in X </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dy</em>&nbsp;</td><td>The distance to translate in Y returns true if the operation succeeded (e.g. did not overflow) </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_sk_canvas.html#a25cb80f3795c44ebcadc901cbc3c23f9">SkCanvas</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/Volumes/disk/skia/trunk/include/utils/<a class="el" href="_sk_proxy_canvas_8h_source.html">SkProxyCanvas.h</a></li>
</ul>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on Tue Oct 20 10:33:05 2009 for Skia by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>

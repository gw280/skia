<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Skia: SkBufferStream Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>SkBufferStream Class Reference</h1><!-- doxytag: class="SkBufferStream" --><!-- doxytag: inherits="SkStream" -->
<p><code>#include &lt;<a class="el" href="_sk_stream_8h_source.html">SkStream.h</a>&gt;</code></p>

<p>Inherits <a class="el" href="class_sk_stream.html">SkStream</a>.</p>
<div class="dynheader">
Collaboration diagram for SkBufferStream:</div>
<div class="dynsection">
<div class="center"><img src="class_sk_buffer_stream__coll__graph.png" border="0" usemap="#_sk_buffer_stream_coll__map" alt="Collaboration graph"/></div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>

<p><a href="class_sk_buffer_stream-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_buffer_stream.html#a5d9aeccad702956e462c9fcce283738f">SkBufferStream</a> (<a class="el" href="class_sk_stream.html">SkStream</a> *proxy, size_t bufferSize=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_buffer_stream.html#abc086d331a365d2e9d3a9931f6ecd740">SkBufferStream</a> (<a class="el" href="class_sk_stream.html">SkStream</a> *proxy, void *buffer, size_t bufferSize)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_buffer_stream.html#a67b1cb5e65a8bd52314aef6a44b2cac4">~SkBufferStream</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_buffer_stream.html#ae3ea03b9396e64af5ec9ffb461adde41">rewind</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_buffer_stream.html#abd227d0fc7bddd23b6876df294afd7b2">getFileName</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_buffer_stream.html#a27f6c752e16c936f11ac81730135f6f0">read</a> (void *buffer, size_t size)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual const void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_buffer_stream.html#a935ca20a1c770189a27e2a8e164071e3">getMemoryBase</a> ()</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>This is a wrapper class that adds buffering to another stream. The caller can provide the buffer, or ask <a class="el" href="class_sk_buffer_stream.html">SkBufferStream</a> to allocated/free it automatically. </p>

<p>Definition at line <a class="el" href="_sk_stream_8h_source.html#l00198">198</a> of file <a class="el" href="_sk_stream_8h_source.html">SkStream.h</a>.</p>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a5d9aeccad702956e462c9fcce283738f"></a><!-- doxytag: member="SkBufferStream::SkBufferStream" ref="a5d9aeccad702956e462c9fcce283738f" args="(SkStream *proxy, size_t bufferSize=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SkBufferStream::SkBufferStream </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_sk_stream.html">SkStream</a> *&nbsp;</td>
          <td class="paramname"> <em>proxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>bufferSize</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Provide the stream to be buffered (proxy), and the size of the buffer that should be used. This will be allocated and freed automatically. If bufferSize is 0, a default buffer size will be used. The proxy stream is referenced, and will be unreferenced in when the bufferstream is destroyed. </p>

</div>
</div>
<a class="anchor" id="abc086d331a365d2e9d3a9931f6ecd740"></a><!-- doxytag: member="SkBufferStream::SkBufferStream" ref="abc086d331a365d2e9d3a9931f6ecd740" args="(SkStream *proxy, void *buffer, size_t bufferSize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SkBufferStream::SkBufferStream </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_sk_stream.html">SkStream</a> *&nbsp;</td>
          <td class="paramname"> <em>proxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>bufferSize</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Provide the stream to be buffered (proxy), and a buffer and size to be used. This buffer is owned by the caller, and must be at least bufferSize bytes big. Passing NULL for buffer will cause the buffer to be allocated/freed automatically. If buffer is not NULL, it is an error for bufferSize to be 0. The proxy stream is referenced, and will be unreferenced in when the bufferstream is destroyed. </p>

</div>
</div>
<a class="anchor" id="a67b1cb5e65a8bd52314aef6a44b2cac4"></a><!-- doxytag: member="SkBufferStream::~SkBufferStream" ref="a67b1cb5e65a8bd52314aef6a44b2cac4" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual SkBufferStream::~SkBufferStream </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="abd227d0fc7bddd23b6876df294afd7b2"></a><!-- doxytag: member="SkBufferStream::getFileName" ref="abd227d0fc7bddd23b6876df294afd7b2" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const char* SkBufferStream::getFileName </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>If this stream represents a file, this method returns the file's name. If it does not, it returns NULL (the default behavior). </p>

<p>Reimplemented from <a class="el" href="class_sk_stream.html#ad9a65d3656c07146a95e4391c8369fd8">SkStream</a>.</p>

</div>
</div>
<a class="anchor" id="a935ca20a1c770189a27e2a8e164071e3"></a><!-- doxytag: member="SkBufferStream::getMemoryBase" ref="a935ca20a1c770189a27e2a8e164071e3" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const void* SkBufferStream::getMemoryBase </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>If the stream is backed by RAM, this method returns the starting address for the data. If not (i.e. it is backed by a file or other structure), this method returns NULL. The default implementation returns NULL. </p>

<p>Reimplemented from <a class="el" href="class_sk_stream.html#a584dce4c2f1af230c1951b5d90da52e8">SkStream</a>.</p>

</div>
</div>
<a class="anchor" id="a27f6c752e16c936f11ac81730135f6f0"></a><!-- doxytag: member="SkBufferStream::read" ref="a27f6c752e16c936f11ac81730135f6f0" args="(void *buffer, size_t size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t SkBufferStream::read </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Called to read or skip size number of bytes. If buffer is NULL and size &gt; 0, skip that many bytes, returning how many were skipped. If buffer is NULL and size == 0, return the total length of the stream. If buffer != NULL, copy the requested number of bytes into buffer, returning how many were copied. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buffer</em>&nbsp;</td><td>If buffer is NULL, ignore and just skip size bytes, otherwise copy size bytes into buffer </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>The number of bytes to skip or copy </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>bytes read on success </dd></dl>

<p>Implements <a class="el" href="class_sk_stream.html#afae3344ee277d55aec3a4fa5fead387a">SkStream</a>.</p>

</div>
</div>
<a class="anchor" id="ae3ea03b9396e64af5ec9ffb461adde41"></a><!-- doxytag: member="SkBufferStream::rewind" ref="ae3ea03b9396e64af5ec9ffb461adde41" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool SkBufferStream::rewind </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Called to rewind to the beginning of the stream. If this cannot be done, return false. </p>

<p>Implements <a class="el" href="class_sk_stream.html#abf7148ef7468ffaf716b024c870a77cc">SkStream</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/core/<a class="el" href="_sk_stream_8h_source.html">SkStream.h</a></li>
</ul>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on Tue Oct 20 11:03:41 2009 for Skia by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>

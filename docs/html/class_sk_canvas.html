<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Skia: SkCanvas Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>SkCanvas Class Reference</h1><!-- doxytag: class="SkCanvas" --><!-- doxytag: inherits="SkRefCnt" -->
<p><code>#include &lt;<a class="el" href="_sk_canvas_8h_source.html">SkCanvas.h</a>&gt;</code></p>

<p>Inherits <a class="el" href="class_sk_ref_cnt.html">SkRefCnt</a>.</p>
<div class="dynheader">
Collaboration diagram for SkCanvas:</div>
<div class="dynsection">
<div class="center"><img src="class_sk_canvas__coll__graph.png" border="0" usemap="#_sk_canvas_coll__map" alt="Collaboration graph"/></div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>

<p><a href="class_sk_canvas-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas_1_1_layer_iter.html">LayerIter</a></td></tr>
<tr><td colspan="2"><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#a438a1ae606d773f95054f1df6ff2bdf2">SaveFlags</a> { <br/>
&nbsp;&nbsp;<a class="el" href="class_sk_canvas.html#a438a1ae606d773f95054f1df6ff2bdf2ad35ad56a0a2ad93e3cc100124f8d44fa">kMatrix_SaveFlag</a> =  0x01, 
<a class="el" href="class_sk_canvas.html#a438a1ae606d773f95054f1df6ff2bdf2ab646ea68b0d6d158273a68bc6db9be22">kClip_SaveFlag</a> =  0x02, 
<a class="el" href="class_sk_canvas.html#a438a1ae606d773f95054f1df6ff2bdf2a055e0bc0d3838dceb88affc0130549a1">kHasAlphaLayer_SaveFlag</a> =  0x04, 
<a class="el" href="class_sk_canvas.html#a438a1ae606d773f95054f1df6ff2bdf2aaeb11c127086083a15997540cf926bfc">kFullColorLayer_SaveFlag</a> =  0x08, 
<br/>
&nbsp;&nbsp;<a class="el" href="class_sk_canvas.html#a438a1ae606d773f95054f1df6ff2bdf2a54e3974c1fdddb63e6ba2e4f223d559b">kClipToLayer_SaveFlag</a> =  0x10, 
<a class="el" href="class_sk_canvas.html#a438a1ae606d773f95054f1df6ff2bdf2a3277ce701c097209f01a40327213664a">kMatrixClip_SaveFlag</a> =  0x03, 
<a class="el" href="class_sk_canvas.html#a438a1ae606d773f95054f1df6ff2bdf2a8dabc4096967ac1a38e702f8ef875eba">kARGB_NoClipLayer_SaveFlag</a> =  0x0F, 
<a class="el" href="class_sk_canvas.html#a438a1ae606d773f95054f1df6ff2bdf2abd7f1274a19813f76b3530429ed36bd5">kARGB_ClipLayer_SaveFlag</a> =  0x1F
<br/>
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#a609b23720c56a138d1e05c027d912328">EdgeType</a> { <a class="el" href="class_sk_canvas.html#a609b23720c56a138d1e05c027d912328ae85a70a6055ffdc865d9e1f3838abdbb">kBW_EdgeType</a>, 
<a class="el" href="class_sk_canvas.html#a609b23720c56a138d1e05c027d912328ac6cbaa0793c53c5fef94c5d7d9505ea3">kAA_EdgeType</a>
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#af1bcd412326a6886e0f260d4d2dc757b">PointMode</a> { <a class="el" href="class_sk_canvas.html#af1bcd412326a6886e0f260d4d2dc757baf596e2b9e5758fc2e5bc8dbdbc191e01">kPoints_PointMode</a>, 
<a class="el" href="class_sk_canvas.html#af1bcd412326a6886e0f260d4d2dc757ba31b9758602c729b8e0fc9b7fac2ac0df">kLines_PointMode</a>, 
<a class="el" href="class_sk_canvas.html#af1bcd412326a6886e0f260d4d2dc757baa1fb56deddeccfc67fca4a7859d24480">kPolygon_PointMode</a>
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#a9ec1e6851be5e6aaa7cab9797822ed58">VertexMode</a> { <a class="el" href="class_sk_canvas.html#a9ec1e6851be5e6aaa7cab9797822ed58a4faee3534ecbc29aae2366af58f169a7">kTriangles_VertexMode</a>, 
<a class="el" href="class_sk_canvas.html#a9ec1e6851be5e6aaa7cab9797822ed58ad4a63070832b8c5dc144c9e932c960b9">kTriangleStrip_VertexMode</a>, 
<a class="el" href="class_sk_canvas.html#a9ec1e6851be5e6aaa7cab9797822ed58a6b60b350ec992b73b4ab3dfe3a5e7636">kTriangleFan_VertexMode</a>
 }</td></tr>
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#af6966c7d203c37df6f3c21f27a4da0d6">SkCanvas</a> (const <a class="el" href="class_sk_bitmap.html">SkBitmap</a> &amp;bitmap)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#a4132f534126179908c93415458643f8a">SkCanvas</a> (<a class="el" href="class_sk_device.html">SkDevice</a> *device=NULL)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#a08a6cac1765929c8b8f2f5b0d2131f4c">~SkCanvas</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#ae7a16c11d4bb28ead36107671393e12d">getViewport</a> (<a class="el" href="struct_sk_i_point.html">SkIPoint</a> *size) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#a2cbf69015d032a4118dfe0f85c1aed5d">setViewport</a> (int x, int y)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_sk_device.html">SkDevice</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#a725c87afc2e53f756c5b18b666456403">getDevice</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_sk_device.html">SkDevice</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#a9f4c51cdbb30cb193dbb0f17d706a6fc">setDevice</a> (<a class="el" href="class_sk_device.html">SkDevice</a> *device)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_sk_device.html">SkDevice</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#a30e49a6e6274341a4474f58c400315e2">setBitmapDevice</a> (const <a class="el" href="class_sk_bitmap.html">SkBitmap</a> &amp;bitmap)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#a19a04ec8b7f13043fbbf14355413af9f">save</a> (<a class="el" href="class_sk_canvas.html#a438a1ae606d773f95054f1df6ff2bdf2">SaveFlags</a> flags=kMatrixClip_SaveFlag)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#ae0782e23cbcc6bb10e015a2bf1f5958a">saveLayer</a> (const <a class="el" href="struct_sk_rect.html">SkRect</a> *bounds, const <a class="el" href="class_sk_paint.html">SkPaint</a> *paint, <a class="el" href="class_sk_canvas.html#a438a1ae606d773f95054f1df6ff2bdf2">SaveFlags</a> flags=kARGB_ClipLayer_SaveFlag)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#a4367f69b9f52ea310e86f408a4daac49">saveLayerAlpha</a> (const <a class="el" href="struct_sk_rect.html">SkRect</a> *bounds, <a class="el" href="_sk_types_8h.html#a6882636f582abdb2a130b7e5ff38aa83">U8CPU</a> alpha, <a class="el" href="class_sk_canvas.html#a438a1ae606d773f95054f1df6ff2bdf2">SaveFlags</a> flags=kARGB_ClipLayer_SaveFlag)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#ae84eb888885e73f152deb0ff65ee1183">restore</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#a55aa24fe45d4b6e59087d8cce81a956e">getSaveCount</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#aae519c51173be795b59f4f4e10c67b9d">restoreToCount</a> (int saveCount)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#a25cb80f3795c44ebcadc901cbc3c23f9">translate</a> (<a class="el" href="_sk_scalar_8h.html#a407e363d56d824ed93bd6d1fda2effcf">SkScalar</a> dx, <a class="el" href="_sk_scalar_8h.html#a407e363d56d824ed93bd6d1fda2effcf">SkScalar</a> dy)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#a0adadc0c50cc8cf4dec80a5e450a6c3c">scale</a> (<a class="el" href="_sk_scalar_8h.html#a407e363d56d824ed93bd6d1fda2effcf">SkScalar</a> sx, <a class="el" href="_sk_scalar_8h.html#a407e363d56d824ed93bd6d1fda2effcf">SkScalar</a> sy)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#ae7954bcc3ce7da3ba845dfa4f573cf57">rotate</a> (<a class="el" href="_sk_scalar_8h.html#a407e363d56d824ed93bd6d1fda2effcf">SkScalar</a> degrees)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#a6b33c84811bee5758d57a63a66476c04">skew</a> (<a class="el" href="_sk_scalar_8h.html#a407e363d56d824ed93bd6d1fda2effcf">SkScalar</a> sx, <a class="el" href="_sk_scalar_8h.html#a407e363d56d824ed93bd6d1fda2effcf">SkScalar</a> sy)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#a2a2f5317b3bd454055df4d9c83b9b5cf">concat</a> (const <a class="el" href="class_sk_matrix.html">SkMatrix</a> &amp;matrix)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#a56ee2bfea2934447dcc573489f55d2bf">setMatrix</a> (const <a class="el" href="class_sk_matrix.html">SkMatrix</a> &amp;matrix)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#aba129108fc68dca01850faf73d5db148">resetMatrix</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#a963d2eef31e9a22e45b7a9f0020d57b1">clipRect</a> (const <a class="el" href="struct_sk_rect.html">SkRect</a> &amp;rect, <a class="el" href="class_sk_region.html#a2ced93c36095d876b020e20cf39f5b54">SkRegion::Op</a> op=SkRegion::kIntersect_Op)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#a8f02d433448c14d01dddae6ecf563600">clipPath</a> (const <a class="el" href="class_sk_path.html">SkPath</a> &amp;path, <a class="el" href="class_sk_region.html#a2ced93c36095d876b020e20cf39f5b54">SkRegion::Op</a> op=SkRegion::kIntersect_Op)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#ad6981b92e554398887cab39f67a529cc">clipRegion</a> (const <a class="el" href="class_sk_region.html">SkRegion</a> &amp;deviceRgn, <a class="el" href="class_sk_region.html#a2ced93c36095d876b020e20cf39f5b54">SkRegion::Op</a> op=SkRegion::kIntersect_Op)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#a203027a80c7da9db2f6311448bab45ae">setClipRegion</a> (const <a class="el" href="class_sk_region.html">SkRegion</a> &amp;deviceRgn)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#a2131c7ea27888387dc0dc4b2a2e29d50">quickReject</a> (const <a class="el" href="struct_sk_rect.html">SkRect</a> &amp;rect, <a class="el" href="class_sk_canvas.html#a609b23720c56a138d1e05c027d912328">EdgeType</a> et) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#a4a0b2af43f2bdb3b494f33d04c0a9695">quickReject</a> (const <a class="el" href="class_sk_path.html">SkPath</a> &amp;path, <a class="el" href="class_sk_canvas.html#a609b23720c56a138d1e05c027d912328">EdgeType</a> et) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#ae9a1e6e339f57eb893afbc161ea902d7">quickRejectY</a> (<a class="el" href="_sk_scalar_8h.html#a407e363d56d824ed93bd6d1fda2effcf">SkScalar</a> top, <a class="el" href="_sk_scalar_8h.html#a407e363d56d824ed93bd6d1fda2effcf">SkScalar</a> bottom, <a class="el" href="class_sk_canvas.html#a609b23720c56a138d1e05c027d912328">EdgeType</a> et) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#a1618ea5bfda0a8fe33474761a7241b2a">getClipBounds</a> (<a class="el" href="struct_sk_rect.html">SkRect</a> *bounds, <a class="el" href="class_sk_canvas.html#a609b23720c56a138d1e05c027d912328">EdgeType</a> et=kAA_EdgeType) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#aff9ca991989b70ac4c88072e0ee8be6b">drawARGB</a> (<a class="el" href="_sk_types_8h.html#a6882636f582abdb2a130b7e5ff38aa83">U8CPU</a> a, <a class="el" href="_sk_types_8h.html#a6882636f582abdb2a130b7e5ff38aa83">U8CPU</a> r, <a class="el" href="_sk_types_8h.html#a6882636f582abdb2a130b7e5ff38aa83">U8CPU</a> g, <a class="el" href="_sk_types_8h.html#a6882636f582abdb2a130b7e5ff38aa83">U8CPU</a> b, <a class="el" href="class_sk_xfermode.html#a73b1831c1491b0a841a20ecf445fff40">SkXfermode::Mode</a> mode=SkXfermode::kSrcOver_Mode)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#a5341b06685c9406b3e7d86283b66cda2">drawColor</a> (<a class="el" href="_sk_color_8h.html#a84c81e6a24ff07a55333acf5603046a8">SkColor</a> color, <a class="el" href="class_sk_xfermode.html#a73b1831c1491b0a841a20ecf445fff40">SkXfermode::Mode</a> mode=SkXfermode::kSrcOver_Mode)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#a68d5e7d505eb881967a9988c75ef4f17">drawPaint</a> (const <a class="el" href="class_sk_paint.html">SkPaint</a> &amp;paint)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#ac3018677c5277dd2e1d31183d41f3297">drawPoints</a> (<a class="el" href="class_sk_canvas.html#af1bcd412326a6886e0f260d4d2dc757b">PointMode</a> mode, size_t count, const <a class="el" href="struct_sk_point.html">SkPoint</a> pts[], const <a class="el" href="class_sk_paint.html">SkPaint</a> &amp;paint)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#a2ebda507728e3d6cc839492593fd7a3d">drawPoint</a> (<a class="el" href="_sk_scalar_8h.html#a407e363d56d824ed93bd6d1fda2effcf">SkScalar</a> x, <a class="el" href="_sk_scalar_8h.html#a407e363d56d824ed93bd6d1fda2effcf">SkScalar</a> y, const <a class="el" href="class_sk_paint.html">SkPaint</a> &amp;paint)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#a18939c446ba411253a7fa3630b70e7bd">drawPoint</a> (<a class="el" href="_sk_scalar_8h.html#a407e363d56d824ed93bd6d1fda2effcf">SkScalar</a> x, <a class="el" href="_sk_scalar_8h.html#a407e363d56d824ed93bd6d1fda2effcf">SkScalar</a> y, <a class="el" href="_sk_color_8h.html#a84c81e6a24ff07a55333acf5603046a8">SkColor</a> color)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#a6532d77a844abb68ba029243ce218ec6">drawLine</a> (<a class="el" href="_sk_scalar_8h.html#a407e363d56d824ed93bd6d1fda2effcf">SkScalar</a> x0, <a class="el" href="_sk_scalar_8h.html#a407e363d56d824ed93bd6d1fda2effcf">SkScalar</a> y0, <a class="el" href="_sk_scalar_8h.html#a407e363d56d824ed93bd6d1fda2effcf">SkScalar</a> x1, <a class="el" href="_sk_scalar_8h.html#a407e363d56d824ed93bd6d1fda2effcf">SkScalar</a> y1, const <a class="el" href="class_sk_paint.html">SkPaint</a> &amp;paint)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#a3bf4d3ff9e3bada28acc7423fffacfc5">drawRect</a> (const <a class="el" href="struct_sk_rect.html">SkRect</a> &amp;rect, const <a class="el" href="class_sk_paint.html">SkPaint</a> &amp;paint)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#a9646a00be01648cb4b6206a84581e8fb">drawIRect</a> (const <a class="el" href="struct_sk_i_rect.html">SkIRect</a> &amp;rect, const <a class="el" href="class_sk_paint.html">SkPaint</a> &amp;paint)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#a484834085e3ae8970bb1009a717032ef">drawRectCoords</a> (<a class="el" href="_sk_scalar_8h.html#a407e363d56d824ed93bd6d1fda2effcf">SkScalar</a> left, <a class="el" href="_sk_scalar_8h.html#a407e363d56d824ed93bd6d1fda2effcf">SkScalar</a> top, <a class="el" href="_sk_scalar_8h.html#a407e363d56d824ed93bd6d1fda2effcf">SkScalar</a> right, <a class="el" href="_sk_scalar_8h.html#a407e363d56d824ed93bd6d1fda2effcf">SkScalar</a> bottom, const <a class="el" href="class_sk_paint.html">SkPaint</a> &amp;paint)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#af9f452bf1cd2f2ec6032056103051c1c">drawOval</a> (const <a class="el" href="struct_sk_rect.html">SkRect</a> &amp;oval, const <a class="el" href="class_sk_paint.html">SkPaint</a> &amp;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#afeec18345530ada3fc5bfd077bc7eb2f">drawCircle</a> (<a class="el" href="_sk_scalar_8h.html#a407e363d56d824ed93bd6d1fda2effcf">SkScalar</a> cx, <a class="el" href="_sk_scalar_8h.html#a407e363d56d824ed93bd6d1fda2effcf">SkScalar</a> cy, <a class="el" href="_sk_scalar_8h.html#a407e363d56d824ed93bd6d1fda2effcf">SkScalar</a> radius, const <a class="el" href="class_sk_paint.html">SkPaint</a> &amp;paint)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#ab7d43d64e7e6d756e60a6d42f3dc472d">drawArc</a> (const <a class="el" href="struct_sk_rect.html">SkRect</a> &amp;oval, <a class="el" href="_sk_scalar_8h.html#a407e363d56d824ed93bd6d1fda2effcf">SkScalar</a> startAngle, <a class="el" href="_sk_scalar_8h.html#a407e363d56d824ed93bd6d1fda2effcf">SkScalar</a> sweepAngle, bool useCenter, const <a class="el" href="class_sk_paint.html">SkPaint</a> &amp;paint)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#ab77ed3c2ed1f8bbe331e1063ab4f98a9">drawRoundRect</a> (const <a class="el" href="struct_sk_rect.html">SkRect</a> &amp;rect, <a class="el" href="_sk_scalar_8h.html#a407e363d56d824ed93bd6d1fda2effcf">SkScalar</a> rx, <a class="el" href="_sk_scalar_8h.html#a407e363d56d824ed93bd6d1fda2effcf">SkScalar</a> ry, const <a class="el" href="class_sk_paint.html">SkPaint</a> &amp;paint)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#a19f1497279f355c61cfdd3686c0e90a3">drawPath</a> (const <a class="el" href="class_sk_path.html">SkPath</a> &amp;path, const <a class="el" href="class_sk_paint.html">SkPaint</a> &amp;paint)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#a17c2d2bd41041981ac8706905d654f47">drawBitmap</a> (const <a class="el" href="class_sk_bitmap.html">SkBitmap</a> &amp;bitmap, <a class="el" href="_sk_scalar_8h.html#a407e363d56d824ed93bd6d1fda2effcf">SkScalar</a> left, <a class="el" href="_sk_scalar_8h.html#a407e363d56d824ed93bd6d1fda2effcf">SkScalar</a> top, const <a class="el" href="class_sk_paint.html">SkPaint</a> *paint=NULL)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#a2521b2f7fe8449e30e286878fec98140">drawBitmapRect</a> (const <a class="el" href="class_sk_bitmap.html">SkBitmap</a> &amp;bitmap, const <a class="el" href="struct_sk_i_rect.html">SkIRect</a> *src, const <a class="el" href="struct_sk_rect.html">SkRect</a> &amp;dst, const <a class="el" href="class_sk_paint.html">SkPaint</a> *paint=NULL)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#a448beaa4b046808e540d1492c40e3566">drawBitmapMatrix</a> (const <a class="el" href="class_sk_bitmap.html">SkBitmap</a> &amp;bitmap, const <a class="el" href="class_sk_matrix.html">SkMatrix</a> &amp;m, const <a class="el" href="class_sk_paint.html">SkPaint</a> *paint=NULL)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#a4385c5584a1fe8777a9974b607bf72ee">drawSprite</a> (const <a class="el" href="class_sk_bitmap.html">SkBitmap</a> &amp;bitmap, int left, int top, const <a class="el" href="class_sk_paint.html">SkPaint</a> *paint=NULL)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#a6abc9c64496983ebee287cfcf3a3d33f">drawText</a> (const void *text, size_t byteLength, <a class="el" href="_sk_scalar_8h.html#a407e363d56d824ed93bd6d1fda2effcf">SkScalar</a> x, <a class="el" href="_sk_scalar_8h.html#a407e363d56d824ed93bd6d1fda2effcf">SkScalar</a> y, const <a class="el" href="class_sk_paint.html">SkPaint</a> &amp;paint)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#a5cafeedbbaf1f8dbf1b3947e6a7dc889">drawPosText</a> (const void *text, size_t byteLength, const <a class="el" href="struct_sk_point.html">SkPoint</a> pos[], const <a class="el" href="class_sk_paint.html">SkPaint</a> &amp;paint)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#add609f47110f6109ad5e25868ab30efc">drawPosTextH</a> (const void *text, size_t byteLength, const <a class="el" href="_sk_scalar_8h.html#a407e363d56d824ed93bd6d1fda2effcf">SkScalar</a> xpos[], <a class="el" href="_sk_scalar_8h.html#a407e363d56d824ed93bd6d1fda2effcf">SkScalar</a> constY, const <a class="el" href="class_sk_paint.html">SkPaint</a> &amp;paint)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#a036430c7980b9ce8eb79b7f483516ac0">drawTextOnPathHV</a> (const void *text, size_t byteLength, const <a class="el" href="class_sk_path.html">SkPath</a> &amp;path, <a class="el" href="_sk_scalar_8h.html#a407e363d56d824ed93bd6d1fda2effcf">SkScalar</a> hOffset, <a class="el" href="_sk_scalar_8h.html#a407e363d56d824ed93bd6d1fda2effcf">SkScalar</a> vOffset, const <a class="el" href="class_sk_paint.html">SkPaint</a> &amp;paint)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#ad48875ca22ddc69bf90164cddb960049">drawTextOnPath</a> (const void *text, size_t byteLength, const <a class="el" href="class_sk_path.html">SkPath</a> &amp;path, const <a class="el" href="class_sk_matrix.html">SkMatrix</a> *matrix, const <a class="el" href="class_sk_paint.html">SkPaint</a> &amp;paint)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#a2fa024453629da8f45e12f4d6fe5b012">drawPicture</a> (<a class="el" href="class_sk_picture.html">SkPicture</a> &amp;picture)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#a81006b6af71fabc802e11ea9277be3cf">drawShape</a> (<a class="el" href="class_sk_shape.html">SkShape</a> *)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#a93a9df6e7ec7aa2f0b4ccc412267654f">drawVertices</a> (<a class="el" href="class_sk_canvas.html#a9ec1e6851be5e6aaa7cab9797822ed58">VertexMode</a> vmode, int vertexCount, const <a class="el" href="struct_sk_point.html">SkPoint</a> vertices[], const <a class="el" href="struct_sk_point.html">SkPoint</a> texs[], const <a class="el" href="_sk_color_8h.html#a84c81e6a24ff07a55333acf5603046a8">SkColor</a> colors[], <a class="el" href="class_sk_xfermode.html">SkXfermode</a> *xmode, const uint16_t indices[], int indexCount, const <a class="el" href="class_sk_paint.html">SkPaint</a> &amp;paint)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_sk_bounder.html">SkBounder</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#a16a8291155c07db7b034d566a45454ee">getBounder</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_sk_bounder.html">SkBounder</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#a717b592a7f796556b314947b8ce87de0">setBounder</a> (<a class="el" href="class_sk_bounder.html">SkBounder</a> *bounder)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_sk_draw_filter.html">SkDrawFilter</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#ac5795c1b5e2353513fd496540ee33911">getDrawFilter</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_sk_draw_filter.html">SkDrawFilter</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#aff4b429d65d4cc621013c7b6f8248004">setDrawFilter</a> (<a class="el" href="class_sk_draw_filter.html">SkDrawFilter</a> *filter)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_sk_matrix.html">SkMatrix</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#a79db014d11218b86ac383d27b51962ae">getTotalMatrix</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_sk_region.html">SkRegion</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#af853a33baf62117f6f7f0b6da96f1874">getTotalClip</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_sk_device.html">SkDevice</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#ad9a7eb604feaf007bcfacff32d6ee91e">createDevice</a> (<a class="el" href="class_sk_bitmap.html#a62602e28fc755def34d7e261bfd0b74a">SkBitmap::Config</a>, int width, int height, bool isOpaque, bool isForLayer)</td></tr>
<tr><td colspan="2"><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#af130ca73ca522fe3150cd9fde78ca17f">commonDrawBitmap</a> (const <a class="el" href="class_sk_bitmap.html">SkBitmap</a> &amp;, const <a class="el" href="class_sk_matrix.html">SkMatrix</a> &amp;m, const <a class="el" href="class_sk_paint.html">SkPaint</a> &amp;paint)</td></tr>
<tr><td colspan="2"><h2>Friends</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#ad95d8ad7a9afbdcc63b08e57527c89f5">SkDrawIter</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>A Canvas encapsulates all of the state about drawing into a device (bitmap). This includes a reference to the device itself, and a stack of matrix/clip values. For any given draw call (e.g. drawRect), the geometry of the object being drawn is transformed by the concatenation of all the matrices in the stack. The transformed geometry is clipped by the intersection of all of the clips in the stack.</p>
<p>While the Canvas holds the state of the drawing device, the state (style) of the object being drawn is held by the Paint, which is provided as a parameter to each of the draw() methods. The Paint holds attributes such as color, typeface, textSize, strokeWidth, shader (e.g. gradients, patterns), etc. </p>

<p>Definition at line <a class="el" href="_sk_canvas_8h_source.html#l00052">52</a> of file <a class="el" href="_sk_canvas_8h_source.html">SkCanvas.h</a>.</p>
<hr/><h2>Member Enumeration Documentation</h2>
<a class="anchor" id="a609b23720c56a138d1e05c027d912328"></a><!-- doxytag: member="SkCanvas::EdgeType" ref="a609b23720c56a138d1e05c027d912328" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_sk_canvas.html#a609b23720c56a138d1e05c027d912328">SkCanvas::EdgeType</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Enum describing how to treat edges when performing quick-reject tests of a geometry against the current clip. Treating them as antialiased (kAA_EdgeType) will take into account the extra pixels that may be drawn if the edge does not lie exactly on a device pixel boundary (after being transformed by the current matrix). </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a609b23720c56a138d1e05c027d912328ae85a70a6055ffdc865d9e1f3838abdbb"></a><!-- doxytag: member="kBW_EdgeType" ref="a609b23720c56a138d1e05c027d912328ae85a70a6055ffdc865d9e1f3838abdbb" args="" -->kBW_EdgeType</em>&nbsp;</td><td>
<p>Treat the edges as B&amp;W (not antialiased) for the purposes of testing against the current clip </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a609b23720c56a138d1e05c027d912328ac6cbaa0793c53c5fef94c5d7d9505ea3"></a><!-- doxytag: member="kAA_EdgeType" ref="a609b23720c56a138d1e05c027d912328ac6cbaa0793c53c5fef94c5d7d9505ea3" args="" -->kAA_EdgeType</em>&nbsp;</td><td>
<p>Treat the edges as antialiased for the purposes of testing against the current clip </p>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="_sk_canvas_8h_source.html#l00263">263</a> of file <a class="el" href="_sk_canvas_8h_source.html">SkCanvas.h</a>.</p>

</div>
</div>
<a class="anchor" id="af1bcd412326a6886e0f260d4d2dc757b"></a><!-- doxytag: member="SkCanvas::PointMode" ref="af1bcd412326a6886e0f260d4d2dc757b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_sk_canvas.html#af1bcd412326a6886e0f260d4d2dc757b">SkCanvas::PointMode</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="af1bcd412326a6886e0f260d4d2dc757baf596e2b9e5758fc2e5bc8dbdbc191e01"></a><!-- doxytag: member="kPoints_PointMode" ref="af1bcd412326a6886e0f260d4d2dc757baf596e2b9e5758fc2e5bc8dbdbc191e01" args="" -->kPoints_PointMode</em>&nbsp;</td><td>
<p>drawPoints draws each point separately </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="af1bcd412326a6886e0f260d4d2dc757ba31b9758602c729b8e0fc9b7fac2ac0df"></a><!-- doxytag: member="kLines_PointMode" ref="af1bcd412326a6886e0f260d4d2dc757ba31b9758602c729b8e0fc9b7fac2ac0df" args="" -->kLines_PointMode</em>&nbsp;</td><td>
<p>drawPoints draws each pair of points as a line segment </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="af1bcd412326a6886e0f260d4d2dc757baa1fb56deddeccfc67fca4a7859d24480"></a><!-- doxytag: member="kPolygon_PointMode" ref="af1bcd412326a6886e0f260d4d2dc757baa1fb56deddeccfc67fca4a7859d24480" args="" -->kPolygon_PointMode</em>&nbsp;</td><td>
<p>drawPoints draws the array of points as a polygon </p>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="_sk_canvas_8h_source.html#l00342">342</a> of file <a class="el" href="_sk_canvas_8h_source.html">SkCanvas.h</a>.</p>

</div>
</div>
<a class="anchor" id="a438a1ae606d773f95054f1df6ff2bdf2"></a><!-- doxytag: member="SkCanvas::SaveFlags" ref="a438a1ae606d773f95054f1df6ff2bdf2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_sk_canvas.html#a438a1ae606d773f95054f1df6ff2bdf2">SkCanvas::SaveFlags</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a438a1ae606d773f95054f1df6ff2bdf2ad35ad56a0a2ad93e3cc100124f8d44fa"></a><!-- doxytag: member="kMatrix_SaveFlag" ref="a438a1ae606d773f95054f1df6ff2bdf2ad35ad56a0a2ad93e3cc100124f8d44fa" args="" -->kMatrix_SaveFlag</em>&nbsp;</td><td>
<p>save the matrix state, restoring it on <a class="el" href="class_sk_canvas.html#ae84eb888885e73f152deb0ff65ee1183">restore()</a> </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a438a1ae606d773f95054f1df6ff2bdf2ab646ea68b0d6d158273a68bc6db9be22"></a><!-- doxytag: member="kClip_SaveFlag" ref="a438a1ae606d773f95054f1df6ff2bdf2ab646ea68b0d6d158273a68bc6db9be22" args="" -->kClip_SaveFlag</em>&nbsp;</td><td>
<p>save the clip state, restoring it on <a class="el" href="class_sk_canvas.html#ae84eb888885e73f152deb0ff65ee1183">restore()</a> </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a438a1ae606d773f95054f1df6ff2bdf2a055e0bc0d3838dceb88affc0130549a1"></a><!-- doxytag: member="kHasAlphaLayer_SaveFlag" ref="a438a1ae606d773f95054f1df6ff2bdf2a055e0bc0d3838dceb88affc0130549a1" args="" -->kHasAlphaLayer_SaveFlag</em>&nbsp;</td><td>
<p>the layer needs to support per-pixel alpha </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a438a1ae606d773f95054f1df6ff2bdf2aaeb11c127086083a15997540cf926bfc"></a><!-- doxytag: member="kFullColorLayer_SaveFlag" ref="a438a1ae606d773f95054f1df6ff2bdf2aaeb11c127086083a15997540cf926bfc" args="" -->kFullColorLayer_SaveFlag</em>&nbsp;</td><td>
<p>the layer needs to support 8-bits per color component </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a438a1ae606d773f95054f1df6ff2bdf2a54e3974c1fdddb63e6ba2e4f223d559b"></a><!-- doxytag: member="kClipToLayer_SaveFlag" ref="a438a1ae606d773f95054f1df6ff2bdf2a54e3974c1fdddb63e6ba2e4f223d559b" args="" -->kClipToLayer_SaveFlag</em>&nbsp;</td><td>
<p>the layer should clip against the bounds argument </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a438a1ae606d773f95054f1df6ff2bdf2a3277ce701c097209f01a40327213664a"></a><!-- doxytag: member="kMatrixClip_SaveFlag" ref="a438a1ae606d773f95054f1df6ff2bdf2a3277ce701c097209f01a40327213664a" args="" -->kMatrixClip_SaveFlag</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a438a1ae606d773f95054f1df6ff2bdf2a8dabc4096967ac1a38e702f8ef875eba"></a><!-- doxytag: member="kARGB_NoClipLayer_SaveFlag" ref="a438a1ae606d773f95054f1df6ff2bdf2a8dabc4096967ac1a38e702f8ef875eba" args="" -->kARGB_NoClipLayer_SaveFlag</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a438a1ae606d773f95054f1df6ff2bdf2abd7f1274a19813f76b3530429ed36bd5"></a><!-- doxytag: member="kARGB_ClipLayer_SaveFlag" ref="a438a1ae606d773f95054f1df6ff2bdf2abd7f1274a19813f76b3530429ed36bd5" args="" -->kARGB_ClipLayer_SaveFlag</em>&nbsp;</td><td>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="_sk_canvas_8h_source.html#l00100">100</a> of file <a class="el" href="_sk_canvas_8h_source.html">SkCanvas.h</a>.</p>

</div>
</div>
<a class="anchor" id="a9ec1e6851be5e6aaa7cab9797822ed58"></a><!-- doxytag: member="SkCanvas::VertexMode" ref="a9ec1e6851be5e6aaa7cab9797822ed58" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_sk_canvas.html#a9ec1e6851be5e6aaa7cab9797822ed58">SkCanvas::VertexMode</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a9ec1e6851be5e6aaa7cab9797822ed58a4faee3534ecbc29aae2366af58f169a7"></a><!-- doxytag: member="kTriangles_VertexMode" ref="a9ec1e6851be5e6aaa7cab9797822ed58a4faee3534ecbc29aae2366af58f169a7" args="" -->kTriangles_VertexMode</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a9ec1e6851be5e6aaa7cab9797822ed58ad4a63070832b8c5dc144c9e932c960b9"></a><!-- doxytag: member="kTriangleStrip_VertexMode" ref="a9ec1e6851be5e6aaa7cab9797822ed58ad4a63070832b8c5dc144c9e932c960b9" args="" -->kTriangleStrip_VertexMode</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a9ec1e6851be5e6aaa7cab9797822ed58a6b60b350ec992b73b4ab3dfe3a5e7636"></a><!-- doxytag: member="kTriangleFan_VertexMode" ref="a9ec1e6851be5e6aaa7cab9797822ed58a6b60b350ec992b73b4ab3dfe3a5e7636" args="" -->kTriangleFan_VertexMode</em>&nbsp;</td><td>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="_sk_canvas_8h_source.html#l00599">599</a> of file <a class="el" href="_sk_canvas_8h_source.html">SkCanvas.h</a>.</p>

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="af6966c7d203c37df6f3c21f27a4da0d6"></a><!-- doxytag: member="SkCanvas::SkCanvas" ref="af6966c7d203c37df6f3c21f27a4da0d6" args="(const SkBitmap &amp;bitmap)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SkCanvas::SkCanvas </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sk_bitmap.html">SkBitmap</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>bitmap</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Construct a canvas with the specified bitmap to draw into. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>bitmap</em>&nbsp;</td><td>Specifies a bitmap for the canvas to draw into. Its structure are copied to the canvas. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4132f534126179908c93415458643f8a"></a><!-- doxytag: member="SkCanvas::SkCanvas" ref="a4132f534126179908c93415458643f8a" args="(SkDevice *device=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SkCanvas::SkCanvas </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_sk_device.html">SkDevice</a> *&nbsp;</td>
          <td class="paramname"> <em>device</em> = <code>NULL</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Construct a canvas with the specified device to draw into. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>device</em>&nbsp;</td><td>Specifies a device for the canvas to draw into. The device may be null. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a08a6cac1765929c8b8f2f5b0d2131f4c"></a><!-- doxytag: member="SkCanvas::~SkCanvas" ref="a08a6cac1765929c8b8f2f5b0d2131f4c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual SkCanvas::~SkCanvas </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a8f02d433448c14d01dddae6ecf563600"></a><!-- doxytag: member="SkCanvas::clipPath" ref="a8f02d433448c14d01dddae6ecf563600" args="(const SkPath &amp;path, SkRegion::Op op=SkRegion::kIntersect_Op)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool SkCanvas::clipPath </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sk_path.html">SkPath</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_sk_region.html#a2ced93c36095d876b020e20cf39f5b54">SkRegion::Op</a>&nbsp;</td>
          <td class="paramname"> <em>op</em> = <code>SkRegion::kIntersect_Op</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Modify the current clip with the specified path. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>path</em>&nbsp;</td><td>The path to apply to the current clip </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>op</em>&nbsp;</td><td>The region op to apply to the current clip </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the canvas' new clip is non-empty </dd></dl>

</div>
</div>
<a class="anchor" id="a963d2eef31e9a22e45b7a9f0020d57b1"></a><!-- doxytag: member="SkCanvas::clipRect" ref="a963d2eef31e9a22e45b7a9f0020d57b1" args="(const SkRect &amp;rect, SkRegion::Op op=SkRegion::kIntersect_Op)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool SkCanvas::clipRect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_sk_rect.html">SkRect</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>rect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_sk_region.html#a2ced93c36095d876b020e20cf39f5b54">SkRegion::Op</a>&nbsp;</td>
          <td class="paramname"> <em>op</em> = <code>SkRegion::kIntersect_Op</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Modify the current clip with the specified rectangle. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rect</em>&nbsp;</td><td>The rect to intersect with the current clip </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>op</em>&nbsp;</td><td>The region op to apply to the current clip </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the canvas' clip is non-empty </dd></dl>

</div>
</div>
<a class="anchor" id="ad6981b92e554398887cab39f67a529cc"></a><!-- doxytag: member="SkCanvas::clipRegion" ref="ad6981b92e554398887cab39f67a529cc" args="(const SkRegion &amp;deviceRgn, SkRegion::Op op=SkRegion::kIntersect_Op)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool SkCanvas::clipRegion </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sk_region.html">SkRegion</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>deviceRgn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_sk_region.html#a2ced93c36095d876b020e20cf39f5b54">SkRegion::Op</a>&nbsp;</td>
          <td class="paramname"> <em>op</em> = <code>SkRegion::kIntersect_Op</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Modify the current clip with the specified region. Note that unlike <a class="el" href="class_sk_canvas.html#a963d2eef31e9a22e45b7a9f0020d57b1">clipRect()</a> and <a class="el" href="class_sk_canvas.html#a8f02d433448c14d01dddae6ecf563600">clipPath()</a> which transform their arguments by the current matrix, <a class="el" href="class_sk_canvas.html#ad6981b92e554398887cab39f67a529cc">clipRegion()</a> assumes its argument is already in device coordinates, and so no transformation is performed. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>deviceRgn</em>&nbsp;</td><td>The region to apply to the current clip </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>op</em>&nbsp;</td><td>The region op to apply to the current clip </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the canvas' new clip is non-empty </dd></dl>

</div>
</div>
<a class="anchor" id="af130ca73ca522fe3150cd9fde78ca17f"></a><!-- doxytag: member="SkCanvas::commonDrawBitmap" ref="af130ca73ca522fe3150cd9fde78ca17f" args="(const SkBitmap &amp;, const SkMatrix &amp;m, const SkPaint &amp;paint)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SkCanvas::commonDrawBitmap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sk_bitmap.html">SkBitmap</a> &amp;&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_sk_matrix.html">SkMatrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_sk_paint.html">SkPaint</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>paint</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a2a2f5317b3bd454055df4d9c83b9b5cf"></a><!-- doxytag: member="SkCanvas::concat" ref="a2a2f5317b3bd454055df4d9c83b9b5cf" args="(const SkMatrix &amp;matrix)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool SkCanvas::concat </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sk_matrix.html">SkMatrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>matrix</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Preconcat the current matrix with the specified matrix. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>matrix</em>&nbsp;</td><td>The matrix to preconcatenate with the current matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the operation succeeded (e.g. did not overflow) </dd></dl>

</div>
</div>
<a class="anchor" id="ad9a7eb604feaf007bcfacff32d6ee91e"></a><!-- doxytag: member="SkCanvas::createDevice" ref="ad9a7eb604feaf007bcfacff32d6ee91e" args="(SkBitmap::Config, int width, int height, bool isOpaque, bool isForLayer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_sk_device.html">SkDevice</a>* SkCanvas::createDevice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_sk_bitmap.html#a62602e28fc755def34d7e261bfd0b74a">SkBitmap::Config</a>&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>isOpaque</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>isForLayer</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>May be overridden by subclasses. This returns a compatible device for this canvas, with the specified config/width/height. If isOpaque is true, then the underlying bitmap is optimized to assume that every pixel will be drawn to, and thus it does not need to clear the alpha channel ahead of time (assuming the specified config supports per-pixel alpha.) If isOpaque is false, then the bitmap should clear its alpha channel. </p>

</div>
</div>
<a class="anchor" id="ab7d43d64e7e6d756e60a6d42f3dc472d"></a><!-- doxytag: member="SkCanvas::drawArc" ref="ab7d43d64e7e6d756e60a6d42f3dc472d" args="(const SkRect &amp;oval, SkScalar startAngle, SkScalar sweepAngle, bool useCenter, const SkPaint &amp;paint)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SkCanvas::drawArc </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_sk_rect.html">SkRect</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>oval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_sk_scalar_8h.html#a407e363d56d824ed93bd6d1fda2effcf">SkScalar</a>&nbsp;</td>
          <td class="paramname"> <em>startAngle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_sk_scalar_8h.html#a407e363d56d824ed93bd6d1fda2effcf">SkScalar</a>&nbsp;</td>
          <td class="paramname"> <em>sweepAngle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>useCenter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_sk_paint.html">SkPaint</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>paint</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Draw the specified arc, which will be scaled to fit inside the specified oval. If the sweep angle is &gt;= 360, then the oval is drawn completely. Note that this differs slightly from <a class="el" href="class_sk_path.html#a60979e20d65b16208289963e098ed6f3">SkPath::arcTo</a>, which treats the sweep angle mod 360. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>oval</em>&nbsp;</td><td>The bounds of oval used to define the shape of the arc </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>startAngle</em>&nbsp;</td><td>Starting angle (in degrees) where the arc begins </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sweepAngle</em>&nbsp;</td><td>Sweep angle (in degrees) measured clockwise </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>useCenter</em>&nbsp;</td><td>true means include the center of the oval. For filling this will draw a wedge. False means just use the arc. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>paint</em>&nbsp;</td><td>The paint used to draw the arc </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aff9ca991989b70ac4c88072e0ee8be6b"></a><!-- doxytag: member="SkCanvas::drawARGB" ref="aff9ca991989b70ac4c88072e0ee8be6b" args="(U8CPU a, U8CPU r, U8CPU g, U8CPU b, SkXfermode::Mode mode=SkXfermode::kSrcOver_Mode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SkCanvas::drawARGB </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_sk_types_8h.html#a6882636f582abdb2a130b7e5ff38aa83">U8CPU</a>&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_sk_types_8h.html#a6882636f582abdb2a130b7e5ff38aa83">U8CPU</a>&nbsp;</td>
          <td class="paramname"> <em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_sk_types_8h.html#a6882636f582abdb2a130b7e5ff38aa83">U8CPU</a>&nbsp;</td>
          <td class="paramname"> <em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_sk_types_8h.html#a6882636f582abdb2a130b7e5ff38aa83">U8CPU</a>&nbsp;</td>
          <td class="paramname"> <em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_sk_xfermode.html#a73b1831c1491b0a841a20ecf445fff40">SkXfermode::Mode</a>&nbsp;</td>
          <td class="paramname"> <em>mode</em> = <code>SkXfermode::kSrcOver_Mode</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Fill the entire canvas' bitmap (restricted to the current clip) with the specified ARGB color, using the specified mode. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a</em>&nbsp;</td><td>the alpha component (0..255) of the color to fill the canvas </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>r</em>&nbsp;</td><td>the red component (0..255) of the color to fill the canvas </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>g</em>&nbsp;</td><td>the green component (0..255) of the color to fill the canvas </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td>the blue component (0..255) of the color to fill the canvas </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mode</em>&nbsp;</td><td>the mode to apply the color in (defaults to SrcOver) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a17c2d2bd41041981ac8706905d654f47"></a><!-- doxytag: member="SkCanvas::drawBitmap" ref="a17c2d2bd41041981ac8706905d654f47" args="(const SkBitmap &amp;bitmap, SkScalar left, SkScalar top, const SkPaint *paint=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SkCanvas::drawBitmap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sk_bitmap.html">SkBitmap</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>bitmap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_sk_scalar_8h.html#a407e363d56d824ed93bd6d1fda2effcf">SkScalar</a>&nbsp;</td>
          <td class="paramname"> <em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_sk_scalar_8h.html#a407e363d56d824ed93bd6d1fda2effcf">SkScalar</a>&nbsp;</td>
          <td class="paramname"> <em>top</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_sk_paint.html">SkPaint</a> *&nbsp;</td>
          <td class="paramname"> <em>paint</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Draw the specified bitmap, with its top/left corner at (x,y), using the specified paint, transformed by the current matrix. Note: if the paint contains a maskfilter that generates a mask which extends beyond the bitmap's original width/height, then the bitmap will be drawn as if it were in a Shader with CLAMP mode. Thus the color outside of the original width/height will be the edge color replicated. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>bitmap</em>&nbsp;</td><td>The bitmap to be drawn </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>left</em>&nbsp;</td><td>The position of the left side of the bitmap being drawn </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>top</em>&nbsp;</td><td>The position of the top side of the bitmap being drawn </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>paint</em>&nbsp;</td><td>The paint used to draw the bitmap, or NULL </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a448beaa4b046808e540d1492c40e3566"></a><!-- doxytag: member="SkCanvas::drawBitmapMatrix" ref="a448beaa4b046808e540d1492c40e3566" args="(const SkBitmap &amp;bitmap, const SkMatrix &amp;m, const SkPaint *paint=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SkCanvas::drawBitmapMatrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sk_bitmap.html">SkBitmap</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>bitmap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_sk_matrix.html">SkMatrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_sk_paint.html">SkPaint</a> *&nbsp;</td>
          <td class="paramname"> <em>paint</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a2521b2f7fe8449e30e286878fec98140"></a><!-- doxytag: member="SkCanvas::drawBitmapRect" ref="a2521b2f7fe8449e30e286878fec98140" args="(const SkBitmap &amp;bitmap, const SkIRect *src, const SkRect &amp;dst, const SkPaint *paint=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SkCanvas::drawBitmapRect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sk_bitmap.html">SkBitmap</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>bitmap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_sk_i_rect.html">SkIRect</a> *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_sk_rect.html">SkRect</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_sk_paint.html">SkPaint</a> *&nbsp;</td>
          <td class="paramname"> <em>paint</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Draw the specified bitmap, with the specified matrix applied (before the canvas' matrix is applied). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>bitmap</em>&nbsp;</td><td>The bitmap to be drawn </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>Optional: specify the subset of the bitmap to be drawn </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dst</em>&nbsp;</td><td>The destination rectangle where the scaled/translated image will be drawn </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>paint</em>&nbsp;</td><td>The paint used to draw the bitmap, or NULL </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afeec18345530ada3fc5bfd077bc7eb2f"></a><!-- doxytag: member="SkCanvas::drawCircle" ref="afeec18345530ada3fc5bfd077bc7eb2f" args="(SkScalar cx, SkScalar cy, SkScalar radius, const SkPaint &amp;paint)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SkCanvas::drawCircle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_sk_scalar_8h.html#a407e363d56d824ed93bd6d1fda2effcf">SkScalar</a>&nbsp;</td>
          <td class="paramname"> <em>cx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_sk_scalar_8h.html#a407e363d56d824ed93bd6d1fda2effcf">SkScalar</a>&nbsp;</td>
          <td class="paramname"> <em>cy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_sk_scalar_8h.html#a407e363d56d824ed93bd6d1fda2effcf">SkScalar</a>&nbsp;</td>
          <td class="paramname"> <em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_sk_paint.html">SkPaint</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>paint</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Draw the specified circle using the specified paint. If radius is &lt;= 0, then nothing will be drawn. The circle will be filled or framed based on the Style in the paint. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cx</em>&nbsp;</td><td>The x-coordinate of the center of the cirle to be drawn </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cy</em>&nbsp;</td><td>The y-coordinate of the center of the cirle to be drawn </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>radius</em>&nbsp;</td><td>The radius of the cirle to be drawn </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>paint</em>&nbsp;</td><td>The paint used to draw the circle </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5341b06685c9406b3e7d86283b66cda2"></a><!-- doxytag: member="SkCanvas::drawColor" ref="a5341b06685c9406b3e7d86283b66cda2" args="(SkColor color, SkXfermode::Mode mode=SkXfermode::kSrcOver_Mode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SkCanvas::drawColor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_sk_color_8h.html#a84c81e6a24ff07a55333acf5603046a8">SkColor</a>&nbsp;</td>
          <td class="paramname"> <em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_sk_xfermode.html#a73b1831c1491b0a841a20ecf445fff40">SkXfermode::Mode</a>&nbsp;</td>
          <td class="paramname"> <em>mode</em> = <code>SkXfermode::kSrcOver_Mode</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Fill the entire canvas' bitmap (restricted to the current clip) with the specified color and mode. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>color</em>&nbsp;</td><td>the color to draw with </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mode</em>&nbsp;</td><td>the mode to apply the color in (defaults to SrcOver) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9646a00be01648cb4b6206a84581e8fb"></a><!-- doxytag: member="SkCanvas::drawIRect" ref="a9646a00be01648cb4b6206a84581e8fb" args="(const SkIRect &amp;rect, const SkPaint &amp;paint)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SkCanvas::drawIRect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_sk_i_rect.html">SkIRect</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>rect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_sk_paint.html">SkPaint</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>paint</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Draw the specified rectangle using the specified paint. The rectangle will be filled or framed based on the Style in the paint. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rect</em>&nbsp;</td><td>The rect to be drawn </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>paint</em>&nbsp;</td><td>The paint used to draw the rect </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_sk_canvas_8h_source.html#l00411">411</a> of file <a class="el" href="_sk_canvas_8h_source.html">SkCanvas.h</a>.</p>

</div>
</div>
<a class="anchor" id="a6532d77a844abb68ba029243ce218ec6"></a><!-- doxytag: member="SkCanvas::drawLine" ref="a6532d77a844abb68ba029243ce218ec6" args="(SkScalar x0, SkScalar y0, SkScalar x1, SkScalar y1, const SkPaint &amp;paint)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SkCanvas::drawLine </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_sk_scalar_8h.html#a407e363d56d824ed93bd6d1fda2effcf">SkScalar</a>&nbsp;</td>
          <td class="paramname"> <em>x0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_sk_scalar_8h.html#a407e363d56d824ed93bd6d1fda2effcf">SkScalar</a>&nbsp;</td>
          <td class="paramname"> <em>y0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_sk_scalar_8h.html#a407e363d56d824ed93bd6d1fda2effcf">SkScalar</a>&nbsp;</td>
          <td class="paramname"> <em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_sk_scalar_8h.html#a407e363d56d824ed93bd6d1fda2effcf">SkScalar</a>&nbsp;</td>
          <td class="paramname"> <em>y1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_sk_paint.html">SkPaint</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>paint</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Draw a line segment with the specified start and stop x,y coordinates, using the specified paint. NOTE: since a line is always "framed", the paint's Style is ignored. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>x0</em>&nbsp;</td><td>The x-coordinate of the start point of the line </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>y0</em>&nbsp;</td><td>The y-coordinate of the start point of the line </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>x1</em>&nbsp;</td><td>The x-coordinate of the end point of the line </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>y1</em>&nbsp;</td><td>The y-coordinate of the end point of the line </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>paint</em>&nbsp;</td><td>The paint used to draw the line </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af9f452bf1cd2f2ec6032056103051c1c"></a><!-- doxytag: member="SkCanvas::drawOval" ref="af9f452bf1cd2f2ec6032056103051c1c" args="(const SkRect &amp;oval, const SkPaint &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SkCanvas::drawOval </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_sk_rect.html">SkRect</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>oval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_sk_paint.html">SkPaint</a> &amp;&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Draw the specified oval using the specified paint. The oval will be filled or framed based on the Style in the paint. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>oval</em>&nbsp;</td><td>The rectangle bounds of the oval to be drawn </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>paint</em>&nbsp;</td><td>The paint used to draw the oval </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a68d5e7d505eb881967a9988c75ef4f17"></a><!-- doxytag: member="SkCanvas::drawPaint" ref="a68d5e7d505eb881967a9988c75ef4f17" args="(const SkPaint &amp;paint)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SkCanvas::drawPaint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sk_paint.html">SkPaint</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>paint</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Fill the entire canvas' bitmap (restricted to the current clip) with the specified paint. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>paint</em>&nbsp;</td><td>The paint used to fill the canvas </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a19f1497279f355c61cfdd3686c0e90a3"></a><!-- doxytag: member="SkCanvas::drawPath" ref="a19f1497279f355c61cfdd3686c0e90a3" args="(const SkPath &amp;path, const SkPaint &amp;paint)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SkCanvas::drawPath </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sk_path.html">SkPath</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_sk_paint.html">SkPaint</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>paint</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Draw the specified path using the specified paint. The path will be filled or framed based on the Style in the paint. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>path</em>&nbsp;</td><td>The path to be drawn </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>paint</em>&nbsp;</td><td>The paint used to draw the path </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2fa024453629da8f45e12f4d6fe5b012"></a><!-- doxytag: member="SkCanvas::drawPicture" ref="a2fa024453629da8f45e12f4d6fe5b012" args="(SkPicture &amp;picture)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SkCanvas::drawPicture </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_sk_picture.html">SkPicture</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>picture</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Draw the picture into this canvas. This method effective brackets the playback of the picture's draw calls with save/restore, so the state of this canvas will be unchanged after this call. This contrasts with the more immediate method <a class="el" href="class_sk_picture.html#adf1b69943f6927166c6a55f3b32ee034">SkPicture::draw()</a>, which does not bracket the canvas with save/restore, thus the canvas may be left in a changed state after the call. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>picture</em>&nbsp;</td><td>The recorded drawing commands to playback into this canvas. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a18939c446ba411253a7fa3630b70e7bd"></a><!-- doxytag: member="SkCanvas::drawPoint" ref="a18939c446ba411253a7fa3630b70e7bd" args="(SkScalar x, SkScalar y, SkColor color)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SkCanvas::drawPoint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_sk_scalar_8h.html#a407e363d56d824ed93bd6d1fda2effcf">SkScalar</a>&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_sk_scalar_8h.html#a407e363d56d824ed93bd6d1fda2effcf">SkScalar</a>&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_sk_color_8h.html#a84c81e6a24ff07a55333acf5603046a8">SkColor</a>&nbsp;</td>
          <td class="paramname"> <em>color</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Draws a single pixel in the specified color. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>The X coordinate of which pixel to draw </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>y</em>&nbsp;</td><td>The Y coordiante of which pixel to draw </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>color</em>&nbsp;</td><td>The color to draw </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2ebda507728e3d6cc839492593fd7a3d"></a><!-- doxytag: member="SkCanvas::drawPoint" ref="a2ebda507728e3d6cc839492593fd7a3d" args="(SkScalar x, SkScalar y, const SkPaint &amp;paint)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SkCanvas::drawPoint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_sk_scalar_8h.html#a407e363d56d824ed93bd6d1fda2effcf">SkScalar</a>&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_sk_scalar_8h.html#a407e363d56d824ed93bd6d1fda2effcf">SkScalar</a>&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_sk_paint.html">SkPaint</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>paint</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Helper method for drawing a single point. See <a class="el" href="class_sk_canvas.html#ac3018677c5277dd2e1d31183d41f3297">drawPoints()</a> for a more details. </p>

</div>
</div>
<a class="anchor" id="ac3018677c5277dd2e1d31183d41f3297"></a><!-- doxytag: member="SkCanvas::drawPoints" ref="ac3018677c5277dd2e1d31183d41f3297" args="(PointMode mode, size_t count, const SkPoint pts[], const SkPaint &amp;paint)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SkCanvas::drawPoints </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_sk_canvas.html#af1bcd412326a6886e0f260d4d2dc757b">PointMode</a>&nbsp;</td>
          <td class="paramname"> <em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_sk_point.html">SkPoint</a>&nbsp;</td>
          <td class="paramname"> <em>pts</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_sk_paint.html">SkPaint</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>paint</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Draw a series of points, interpreted based on the PointMode mode. For all modes, the count parameter is interpreted as the total number of points. For kLine mode, count/2 line segments are drawn. For kPoint mode, each point is drawn centered at its coordinate, and its size is specified by the paint's stroke-width. It draws as a square, unless the paint's cap-type is round, in which the points are drawn as circles. For kLine mode, each pair of points is drawn as a line segment, respecting the paint's settings for cap/join/width. For kPolygon mode, the entire array is drawn as a series of connected line segments. Note that, while similar, kLine and kPolygon modes draw slightly differently than the equivalent path built with a series of moveto, lineto calls, in that the path will draw all of its contours at once, with no interactions if contours intersect each other (think XOR xfermode). drawPoints always draws each element one at a time. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mode</em>&nbsp;</td><td>PointMode specifying how to draw the array of points. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>The number of points in the array </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pts</em>&nbsp;</td><td>Array of points to draw </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>paint</em>&nbsp;</td><td>The paint used to draw the points </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5cafeedbbaf1f8dbf1b3947e6a7dc889"></a><!-- doxytag: member="SkCanvas::drawPosText" ref="a5cafeedbbaf1f8dbf1b3947e6a7dc889" args="(const void *text, size_t byteLength, const SkPoint pos[], const SkPaint &amp;paint)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SkCanvas::drawPosText </td>
          <td>(</td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>byteLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_sk_point.html">SkPoint</a>&nbsp;</td>
          <td class="paramname"> <em>pos</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_sk_paint.html">SkPaint</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>paint</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Draw the text, with each character/glyph origin specified by the pos[] array. The origin is interpreted by the Align setting in the paint. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>text</em>&nbsp;</td><td>The text to be drawn </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>byteLength</em>&nbsp;</td><td>The number of bytes to read from the text parameter </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pos</em>&nbsp;</td><td>Array of positions, used to position each character </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>paint</em>&nbsp;</td><td>The paint used for the text (e.g. color, size, style) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="add609f47110f6109ad5e25868ab30efc"></a><!-- doxytag: member="SkCanvas::drawPosTextH" ref="add609f47110f6109ad5e25868ab30efc" args="(const void *text, size_t byteLength, const SkScalar xpos[], SkScalar constY, const SkPaint &amp;paint)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SkCanvas::drawPosTextH </td>
          <td>(</td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>byteLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_sk_scalar_8h.html#a407e363d56d824ed93bd6d1fda2effcf">SkScalar</a>&nbsp;</td>
          <td class="paramname"> <em>xpos</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_sk_scalar_8h.html#a407e363d56d824ed93bd6d1fda2effcf">SkScalar</a>&nbsp;</td>
          <td class="paramname"> <em>constY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_sk_paint.html">SkPaint</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>paint</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Draw the text, with each character/glyph origin specified by the x coordinate taken from the xpos[] array, and the y from the constY param. The origin is interpreted by the Align setting in the paint. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>text</em>&nbsp;</td><td>The text to be drawn </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>byteLength</em>&nbsp;</td><td>The number of bytes to read from the text parameter </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>xpos</em>&nbsp;</td><td>Array of x-positions, used to position each character </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>constY</em>&nbsp;</td><td>The shared Y coordinate for all of the positions </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>paint</em>&nbsp;</td><td>The paint used for the text (e.g. color, size, style) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3bf4d3ff9e3bada28acc7423fffacfc5"></a><!-- doxytag: member="SkCanvas::drawRect" ref="a3bf4d3ff9e3bada28acc7423fffacfc5" args="(const SkRect &amp;rect, const SkPaint &amp;paint)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SkCanvas::drawRect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_sk_rect.html">SkRect</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>rect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_sk_paint.html">SkPaint</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>paint</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Draw the specified rectangle using the specified paint. The rectangle will be filled or stroked based on the Style in the paint. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rect</em>&nbsp;</td><td>The rect to be drawn </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>paint</em>&nbsp;</td><td>The paint used to draw the rect </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a484834085e3ae8970bb1009a717032ef"></a><!-- doxytag: member="SkCanvas::drawRectCoords" ref="a484834085e3ae8970bb1009a717032ef" args="(SkScalar left, SkScalar top, SkScalar right, SkScalar bottom, const SkPaint &amp;paint)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SkCanvas::drawRectCoords </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_sk_scalar_8h.html#a407e363d56d824ed93bd6d1fda2effcf">SkScalar</a>&nbsp;</td>
          <td class="paramname"> <em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_sk_scalar_8h.html#a407e363d56d824ed93bd6d1fda2effcf">SkScalar</a>&nbsp;</td>
          <td class="paramname"> <em>top</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_sk_scalar_8h.html#a407e363d56d824ed93bd6d1fda2effcf">SkScalar</a>&nbsp;</td>
          <td class="paramname"> <em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_sk_scalar_8h.html#a407e363d56d824ed93bd6d1fda2effcf">SkScalar</a>&nbsp;</td>
          <td class="paramname"> <em>bottom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_sk_paint.html">SkPaint</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>paint</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Draw the specified rectangle using the specified paint. The rectangle will be filled or framed based on the Style in the paint. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>left</em>&nbsp;</td><td>The left side of the rectangle to be drawn </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>top</em>&nbsp;</td><td>The top side of the rectangle to be drawn </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>right</em>&nbsp;</td><td>The right side of the rectangle to be drawn </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bottom</em>&nbsp;</td><td>The bottom side of the rectangle to be drawn </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>paint</em>&nbsp;</td><td>The paint used to draw the rect </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab77ed3c2ed1f8bbe331e1063ab4f98a9"></a><!-- doxytag: member="SkCanvas::drawRoundRect" ref="ab77ed3c2ed1f8bbe331e1063ab4f98a9" args="(const SkRect &amp;rect, SkScalar rx, SkScalar ry, const SkPaint &amp;paint)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SkCanvas::drawRoundRect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_sk_rect.html">SkRect</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>rect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_sk_scalar_8h.html#a407e363d56d824ed93bd6d1fda2effcf">SkScalar</a>&nbsp;</td>
          <td class="paramname"> <em>rx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_sk_scalar_8h.html#a407e363d56d824ed93bd6d1fda2effcf">SkScalar</a>&nbsp;</td>
          <td class="paramname"> <em>ry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_sk_paint.html">SkPaint</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>paint</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Draw the specified round-rect using the specified paint. The round-rect will be filled or framed based on the Style in the paint. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rect</em>&nbsp;</td><td>The rectangular bounds of the roundRect to be drawn </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rx</em>&nbsp;</td><td>The x-radius of the oval used to round the corners </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ry</em>&nbsp;</td><td>The y-radius of the oval used to round the corners </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>paint</em>&nbsp;</td><td>The paint used to draw the roundRect </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a81006b6af71fabc802e11ea9277be3cf"></a><!-- doxytag: member="SkCanvas::drawShape" ref="a81006b6af71fabc802e11ea9277be3cf" args="(SkShape *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SkCanvas::drawShape </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_sk_shape.html">SkShape</a> *&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Draws the specified shape </p>

</div>
</div>
<a class="anchor" id="a4385c5584a1fe8777a9974b607bf72ee"></a><!-- doxytag: member="SkCanvas::drawSprite" ref="a4385c5584a1fe8777a9974b607bf72ee" args="(const SkBitmap &amp;bitmap, int left, int top, const SkPaint *paint=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SkCanvas::drawSprite </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sk_bitmap.html">SkBitmap</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>bitmap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>top</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_sk_paint.html">SkPaint</a> *&nbsp;</td>
          <td class="paramname"> <em>paint</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Draw the specified bitmap, with its top/left corner at (x,y), NOT transformed by the current matrix. Note: if the paint contains a maskfilter that generates a mask which extends beyond the bitmap's original width/height, then the bitmap will be drawn as if it were in a Shader with CLAMP mode. Thus the color outside of the original width/height will be the edge color replicated. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>bitmap</em>&nbsp;</td><td>The bitmap to be drawn </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>left</em>&nbsp;</td><td>The position of the left side of the bitmap being drawn </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>top</em>&nbsp;</td><td>The position of the top side of the bitmap being drawn </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>paint</em>&nbsp;</td><td>The paint used to draw the bitmap, or NULL </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6abc9c64496983ebee287cfcf3a3d33f"></a><!-- doxytag: member="SkCanvas::drawText" ref="a6abc9c64496983ebee287cfcf3a3d33f" args="(const void *text, size_t byteLength, SkScalar x, SkScalar y, const SkPaint &amp;paint)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SkCanvas::drawText </td>
          <td>(</td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>byteLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_sk_scalar_8h.html#a407e363d56d824ed93bd6d1fda2effcf">SkScalar</a>&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_sk_scalar_8h.html#a407e363d56d824ed93bd6d1fda2effcf">SkScalar</a>&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_sk_paint.html">SkPaint</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>paint</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Draw the text, with origin at (x,y), using the specified paint. The origin is interpreted based on the Align setting in the paint. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>text</em>&nbsp;</td><td>The text to be drawn </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>byteLength</em>&nbsp;</td><td>The number of bytes to read from the text parameter </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>The x-coordinate of the origin of the text being drawn </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>y</em>&nbsp;</td><td>The y-coordinate of the origin of the text being drawn </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>paint</em>&nbsp;</td><td>The paint used for the text (e.g. color, size, style) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad48875ca22ddc69bf90164cddb960049"></a><!-- doxytag: member="SkCanvas::drawTextOnPath" ref="ad48875ca22ddc69bf90164cddb960049" args="(const void *text, size_t byteLength, const SkPath &amp;path, const SkMatrix *matrix, const SkPaint &amp;paint)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SkCanvas::drawTextOnPath </td>
          <td>(</td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>byteLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_sk_path.html">SkPath</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_sk_matrix.html">SkMatrix</a> *&nbsp;</td>
          <td class="paramname"> <em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_sk_paint.html">SkPaint</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>paint</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Draw the text, with origin at (x,y), using the specified paint, along the specified path. The paint's Align setting determins where along the path to start the text. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>text</em>&nbsp;</td><td>The text to be drawn </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>byteLength</em>&nbsp;</td><td>The number of bytes to read from the text parameter </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>path</em>&nbsp;</td><td>The path the text should follow for its baseline </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>matrix</em>&nbsp;</td><td>(may be null) Applied to the text before it is mapped onto the path </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>paint</em>&nbsp;</td><td>The paint used for the text </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a036430c7980b9ce8eb79b7f483516ac0"></a><!-- doxytag: member="SkCanvas::drawTextOnPathHV" ref="a036430c7980b9ce8eb79b7f483516ac0" args="(const void *text, size_t byteLength, const SkPath &amp;path, SkScalar hOffset, SkScalar vOffset, const SkPaint &amp;paint)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SkCanvas::drawTextOnPathHV </td>
          <td>(</td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>byteLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_sk_path.html">SkPath</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_sk_scalar_8h.html#a407e363d56d824ed93bd6d1fda2effcf">SkScalar</a>&nbsp;</td>
          <td class="paramname"> <em>hOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_sk_scalar_8h.html#a407e363d56d824ed93bd6d1fda2effcf">SkScalar</a>&nbsp;</td>
          <td class="paramname"> <em>vOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_sk_paint.html">SkPaint</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>paint</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Draw the text, with origin at (x,y), using the specified paint, along the specified path. The paint's Align setting determins where along the path to start the text. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>text</em>&nbsp;</td><td>The text to be drawn </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>byteLength</em>&nbsp;</td><td>The number of bytes to read from the text parameter </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>path</em>&nbsp;</td><td>The path the text should follow for its baseline </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>hOffset</em>&nbsp;</td><td>The distance along the path to add to the text's starting position </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vOffset</em>&nbsp;</td><td>The distance above(-) or below(+) the path to position the text </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>paint</em>&nbsp;</td><td>The paint used for the text </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a93a9df6e7ec7aa2f0b4ccc412267654f"></a><!-- doxytag: member="SkCanvas::drawVertices" ref="a93a9df6e7ec7aa2f0b4ccc412267654f" args="(VertexMode vmode, int vertexCount, const SkPoint vertices[], const SkPoint texs[], const SkColor colors[], SkXfermode *xmode, const uint16_t indices[], int indexCount, const SkPaint &amp;paint)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SkCanvas::drawVertices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_sk_canvas.html#a9ec1e6851be5e6aaa7cab9797822ed58">VertexMode</a>&nbsp;</td>
          <td class="paramname"> <em>vmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>vertexCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_sk_point.html">SkPoint</a>&nbsp;</td>
          <td class="paramname"> <em>vertices</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_sk_point.html">SkPoint</a>&nbsp;</td>
          <td class="paramname"> <em>texs</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_sk_color_8h.html#a84c81e6a24ff07a55333acf5603046a8">SkColor</a>&nbsp;</td>
          <td class="paramname"> <em>colors</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_sk_xfermode.html">SkXfermode</a> *&nbsp;</td>
          <td class="paramname"> <em>xmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&nbsp;</td>
          <td class="paramname"> <em>indices</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>indexCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_sk_paint.html">SkPaint</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>paint</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Draw the array of vertices, interpreted as triangles (based on mode). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vmode</em>&nbsp;</td><td>How to interpret the array of vertices </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vertexCount</em>&nbsp;</td><td>The number of points in the vertices array (and corresponding texs and colors arrays if non-null) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vertices</em>&nbsp;</td><td>Array of vertices for the mesh </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>texs</em>&nbsp;</td><td>May be null. If not null, specifies the coordinate in texture space for each vertex. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>colors</em>&nbsp;</td><td>May be null. If not null, specifies a color for each vertex, to be interpolated across the triangle. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>xmode</em>&nbsp;</td><td>Used if both texs and colors are present. In this case the colors are combined with the texture using mode, before being drawn using the paint. If mode is null, then kMultiply_Mode is used. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>indices</em>&nbsp;</td><td>If not null, array of indices to reference into the vertex (texs, colors) array. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>indexCount</em>&nbsp;</td><td>number of entries in the indices array (if not null) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>paint</em>&nbsp;</td><td>Specifies the shader/texture if present. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a16a8291155c07db7b034d566a45454ee"></a><!-- doxytag: member="SkCanvas::getBounder" ref="a16a8291155c07db7b034d566a45454ee" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sk_bounder.html">SkBounder</a>* SkCanvas::getBounder </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the current bounder object. The bounder's reference count is unchaged. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the canva's bounder (or NULL). </dd></dl>

<p>Definition at line <a class="el" href="_sk_canvas_8h_source.html#l00635">635</a> of file <a class="el" href="_sk_canvas_8h_source.html">SkCanvas.h</a>.</p>

</div>
</div>
<a class="anchor" id="a1618ea5bfda0a8fe33474761a7241b2a"></a><!-- doxytag: member="SkCanvas::getClipBounds" ref="a1618ea5bfda0a8fe33474761a7241b2a" args="(SkRect *bounds, EdgeType et=kAA_EdgeType) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SkCanvas::getClipBounds </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_sk_rect.html">SkRect</a> *&nbsp;</td>
          <td class="paramname"> <em>bounds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_sk_canvas.html#a609b23720c56a138d1e05c027d912328">EdgeType</a>&nbsp;</td>
          <td class="paramname"> <em>et</em> = <code>kAA_EdgeType</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the bounds of the current clip (in local coordinates) in the bounds parameter, and return true if it is non-empty. This can be useful in a way similar to quickReject, in that it tells you that drawing outside of these bounds will be clipped out. </p>

</div>
</div>
<a class="anchor" id="a725c87afc2e53f756c5b18b666456403"></a><!-- doxytag: member="SkCanvas::getDevice" ref="a725c87afc2e53f756c5b18b666456403" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sk_device.html">SkDevice</a>* SkCanvas::getDevice </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the canvas' device object, which may be null. The device holds the bitmap of the pixels that the canvas draws into. The reference count of the returned device is not changed by this call. </p>

</div>
</div>
<a class="anchor" id="ac5795c1b5e2353513fd496540ee33911"></a><!-- doxytag: member="SkCanvas::getDrawFilter" ref="ac5795c1b5e2353513fd496540ee33911" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sk_draw_filter.html">SkDrawFilter</a>* SkCanvas::getDrawFilter </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the current filter object. The filter's reference count is not affected. The filter is part of the state this is affected by save/restore. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the canvas' filter (or NULL). </dd></dl>

</div>
</div>
<a class="anchor" id="a55aa24fe45d4b6e59087d8cce81a956e"></a><!-- doxytag: member="SkCanvas::getSaveCount" ref="a55aa24fe45d4b6e59087d8cce81a956e" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SkCanvas::getSaveCount </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the number of matrix/clip states on the SkCanvas' private stack. This will equal # <a class="el" href="class_sk_canvas.html#a19a04ec8b7f13043fbbf14355413af9f">save()</a> calls - # <a class="el" href="class_sk_canvas.html#ae84eb888885e73f152deb0ff65ee1183">restore()</a> calls. </p>

</div>
</div>
<a class="anchor" id="af853a33baf62117f6f7f0b6da96f1874"></a><!-- doxytag: member="SkCanvas::getTotalClip" ref="af853a33baf62117f6f7f0b6da96f1874" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_sk_region.html">SkRegion</a>&amp; SkCanvas::getTotalClip </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the current device clip (concatenation of all clip calls). This does not account for the translate in any of the devices. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the current device clip (concatenation of all clip calls). </dd></dl>

</div>
</div>
<a class="anchor" id="a79db014d11218b86ac383d27b51962ae"></a><!-- doxytag: member="SkCanvas::getTotalMatrix" ref="a79db014d11218b86ac383d27b51962ae" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_sk_matrix.html">SkMatrix</a>&amp; SkCanvas::getTotalMatrix </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the current matrix on the canvas. This does not account for the translate in any of the devices. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The current matrix on the canvas. </dd></dl>

</div>
</div>
<a class="anchor" id="ae7a16c11d4bb28ead36107671393e12d"></a><!-- doxytag: member="SkCanvas::getViewport" ref="ae7a16c11d4bb28ead36107671393e12d" args="(SkIPoint *size) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool SkCanvas::getViewport </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_sk_i_point.html">SkIPoint</a> *&nbsp;</td>
          <td class="paramname"> <em>size</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>If this subclass of <a class="el" href="class_sk_canvas.html">SkCanvas</a> supports GL viewports, return true and set size (if not null) to the size of the viewport. If it is not supported, ignore vp and return false. </p>

</div>
</div>
<a class="anchor" id="a4a0b2af43f2bdb3b494f33d04c0a9695"></a><!-- doxytag: member="SkCanvas::quickReject" ref="a4a0b2af43f2bdb3b494f33d04c0a9695" args="(const SkPath &amp;path, EdgeType et) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SkCanvas::quickReject </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sk_path.html">SkPath</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_sk_canvas.html#a609b23720c56a138d1e05c027d912328">EdgeType</a>&nbsp;</td>
          <td class="paramname"> <em>et</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return true if the specified path, after being transformed by the current matrix, would lie completely outside of the current clip. Call this to check if an area you intend to draw into is clipped out (and therefore you can skip making the draw calls). Note, for speed it may return false even if the path itself might not intersect the clip (i.e. the bounds of the path intersects, but the path does not). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>path</em>&nbsp;</td><td>The path to compare with the current clip </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>et</em>&nbsp;</td><td>specifies how to treat the edges (see EdgeType) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the path (transformed by the canvas' matrix) does not intersect with the canvas' clip </dd></dl>

</div>
</div>
<a class="anchor" id="a2131c7ea27888387dc0dc4b2a2e29d50"></a><!-- doxytag: member="SkCanvas::quickReject" ref="a2131c7ea27888387dc0dc4b2a2e29d50" args="(const SkRect &amp;rect, EdgeType et) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SkCanvas::quickReject </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_sk_rect.html">SkRect</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>rect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_sk_canvas.html#a609b23720c56a138d1e05c027d912328">EdgeType</a>&nbsp;</td>
          <td class="paramname"> <em>et</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return true if the specified rectangle, after being transformed by the current matrix, would lie completely outside of the current clip. Call this to check if an area you intend to draw into is clipped out (and therefore you can skip making the draw calls). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rect</em>&nbsp;</td><td>the rect to compare with the current clip </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>et</em>&nbsp;</td><td>specifies how to treat the edges (see EdgeType) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the rect (transformed by the canvas' matrix) does not intersect with the canvas' clip </dd></dl>

</div>
</div>
<a class="anchor" id="ae9a1e6e339f57eb893afbc161ea902d7"></a><!-- doxytag: member="SkCanvas::quickRejectY" ref="ae9a1e6e339f57eb893afbc161ea902d7" args="(SkScalar top, SkScalar bottom, EdgeType et) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SkCanvas::quickRejectY </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_sk_scalar_8h.html#a407e363d56d824ed93bd6d1fda2effcf">SkScalar</a>&nbsp;</td>
          <td class="paramname"> <em>top</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_sk_scalar_8h.html#a407e363d56d824ed93bd6d1fda2effcf">SkScalar</a>&nbsp;</td>
          <td class="paramname"> <em>bottom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_sk_canvas.html#a609b23720c56a138d1e05c027d912328">EdgeType</a>&nbsp;</td>
          <td class="paramname"> <em>et</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return true if the horizontal band specified by top and bottom is completely clipped out. This is a conservative calculation, meaning that it is possible that if the method returns false, the band may still in fact be clipped out, but the converse is not true. If this method returns true, then the band is guaranteed to be clipped out. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>top</em>&nbsp;</td><td>The top of the horizontal band to compare with the clip </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bottom</em>&nbsp;</td><td>The bottom of the horizontal and to compare with the clip </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the horizontal band is completely clipped out (i.e. does not intersect the current clip) </dd></dl>

</div>
</div>
<a class="anchor" id="aba129108fc68dca01850faf73d5db148"></a><!-- doxytag: member="SkCanvas::resetMatrix" ref="aba129108fc68dca01850faf73d5db148" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SkCanvas::resetMatrix </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Helper for setMatrix(identity). Sets the current matrix to identity. </p>

</div>
</div>
<a class="anchor" id="ae84eb888885e73f152deb0ff65ee1183"></a><!-- doxytag: member="SkCanvas::restore" ref="ae84eb888885e73f152deb0ff65ee1183" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SkCanvas::restore </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This call balances a previous call to <a class="el" href="class_sk_canvas.html#a19a04ec8b7f13043fbbf14355413af9f">save()</a>, and is used to remove all modifications to the matrix/clip state since the last save call. It is an error to call <a class="el" href="class_sk_canvas.html#ae84eb888885e73f152deb0ff65ee1183">restore()</a> more times than <a class="el" href="class_sk_canvas.html#a19a04ec8b7f13043fbbf14355413af9f">save()</a> was called. </p>

</div>
</div>
<a class="anchor" id="aae519c51173be795b59f4f4e10c67b9d"></a><!-- doxytag: member="SkCanvas::restoreToCount" ref="aae519c51173be795b59f4f4e10c67b9d" args="(int saveCount)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SkCanvas::restoreToCount </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>saveCount</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Efficient way to pop any calls to <a class="el" href="class_sk_canvas.html#a19a04ec8b7f13043fbbf14355413af9f">save()</a> that happened after the save count reached saveCount. It is an error for saveCount to be less than <a class="el" href="class_sk_canvas.html#a55aa24fe45d4b6e59087d8cce81a956e">getSaveCount()</a> </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>saveCount</em>&nbsp;</td><td>The number of <a class="el" href="class_sk_canvas.html#a19a04ec8b7f13043fbbf14355413af9f">save()</a> levels to restore from </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae7954bcc3ce7da3ba845dfa4f573cf57"></a><!-- doxytag: member="SkCanvas::rotate" ref="ae7954bcc3ce7da3ba845dfa4f573cf57" args="(SkScalar degrees)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool SkCanvas::rotate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_sk_scalar_8h.html#a407e363d56d824ed93bd6d1fda2effcf">SkScalar</a>&nbsp;</td>
          <td class="paramname"> <em>degrees</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Preconcat the current matrix with the specified rotation. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>degrees</em>&nbsp;</td><td>The amount to rotate, in degrees returns true if the operation succeeded (e.g. did not overflow) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a19a04ec8b7f13043fbbf14355413af9f"></a><!-- doxytag: member="SkCanvas::save" ref="a19a04ec8b7f13043fbbf14355413af9f" args="(SaveFlags flags=kMatrixClip_SaveFlag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int SkCanvas::save </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_sk_canvas.html#a438a1ae606d773f95054f1df6ff2bdf2">SaveFlags</a>&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>kMatrixClip_SaveFlag</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This call saves the current matrix and clip information, and pushes a copy onto a private stack. Subsequent calls to translate, scale, rotate, skew, concat or clipRect, clipPath all operate on this copy. When the balancing call to <a class="el" href="class_sk_canvas.html#ae84eb888885e73f152deb0ff65ee1183">restore()</a> is made, this copy is deleted and the previous matrix/clip state is restored. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The value to pass to <a class="el" href="class_sk_canvas.html#aae519c51173be795b59f4f4e10c67b9d">restoreToCount()</a> to balance this <a class="el" href="class_sk_canvas.html#a19a04ec8b7f13043fbbf14355413af9f">save()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ae0782e23cbcc6bb10e015a2bf1f5958a"></a><!-- doxytag: member="SkCanvas::saveLayer" ref="ae0782e23cbcc6bb10e015a2bf1f5958a" args="(const SkRect *bounds, const SkPaint *paint, SaveFlags flags=kARGB_ClipLayer_SaveFlag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int SkCanvas::saveLayer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_sk_rect.html">SkRect</a> *&nbsp;</td>
          <td class="paramname"> <em>bounds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_sk_paint.html">SkPaint</a> *&nbsp;</td>
          <td class="paramname"> <em>paint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_sk_canvas.html#a438a1ae606d773f95054f1df6ff2bdf2">SaveFlags</a>&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>kARGB_ClipLayer_SaveFlag</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This behaves the same as <a class="el" href="class_sk_canvas.html#a19a04ec8b7f13043fbbf14355413af9f">save()</a>, but in addition it allocates an offscreen bitmap. All drawing calls are directed there, and only when the balancing call to <a class="el" href="class_sk_canvas.html#ae84eb888885e73f152deb0ff65ee1183">restore()</a> is made is that offscreen transfered to the canvas (or the previous layer). Subsequent calls to translate, scale, rotate, skew, concat or clipRect, clipPath all operate on this copy. When the balancing call to <a class="el" href="class_sk_canvas.html#ae84eb888885e73f152deb0ff65ee1183">restore()</a> is made, this copy is deleted and the previous matrix/clip state is restored. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>bounds</em>&nbsp;</td><td>(may be null) the maximum size the offscreen bitmap needs to be (in local coordinates) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>paint</em>&nbsp;</td><td>(may be null) This is copied, and is applied to the offscreen when <a class="el" href="class_sk_canvas.html#ae84eb888885e73f152deb0ff65ee1183">restore()</a> is called </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>LayerFlags </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The value to pass to <a class="el" href="class_sk_canvas.html#aae519c51173be795b59f4f4e10c67b9d">restoreToCount()</a> to balance this <a class="el" href="class_sk_canvas.html#a19a04ec8b7f13043fbbf14355413af9f">save()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a4367f69b9f52ea310e86f408a4daac49"></a><!-- doxytag: member="SkCanvas::saveLayerAlpha" ref="a4367f69b9f52ea310e86f408a4daac49" args="(const SkRect *bounds, U8CPU alpha, SaveFlags flags=kARGB_ClipLayer_SaveFlag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SkCanvas::saveLayerAlpha </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_sk_rect.html">SkRect</a> *&nbsp;</td>
          <td class="paramname"> <em>bounds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_sk_types_8h.html#a6882636f582abdb2a130b7e5ff38aa83">U8CPU</a>&nbsp;</td>
          <td class="paramname"> <em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_sk_canvas.html#a438a1ae606d773f95054f1df6ff2bdf2">SaveFlags</a>&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>kARGB_ClipLayer_SaveFlag</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This behaves the same as <a class="el" href="class_sk_canvas.html#a19a04ec8b7f13043fbbf14355413af9f">save()</a>, but in addition it allocates an offscreen bitmap. All drawing calls are directed there, and only when the balancing call to <a class="el" href="class_sk_canvas.html#ae84eb888885e73f152deb0ff65ee1183">restore()</a> is made is that offscreen transfered to the canvas (or the previous layer). Subsequent calls to translate, scale, rotate, skew, concat or clipRect, clipPath all operate on this copy. When the balancing call to <a class="el" href="class_sk_canvas.html#ae84eb888885e73f152deb0ff65ee1183">restore()</a> is made, this copy is deleted and the previous matrix/clip state is restored. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>bounds</em>&nbsp;</td><td>(may be null) the maximum size the offscreen bitmap needs to be (in local coordinates) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>alpha</em>&nbsp;</td><td>This is applied to the offscreen when <a class="el" href="class_sk_canvas.html#ae84eb888885e73f152deb0ff65ee1183">restore()</a> is called. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>LayerFlags </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The value to pass to <a class="el" href="class_sk_canvas.html#aae519c51173be795b59f4f4e10c67b9d">restoreToCount()</a> to balance this <a class="el" href="class_sk_canvas.html#a19a04ec8b7f13043fbbf14355413af9f">save()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a0adadc0c50cc8cf4dec80a5e450a6c3c"></a><!-- doxytag: member="SkCanvas::scale" ref="a0adadc0c50cc8cf4dec80a5e450a6c3c" args="(SkScalar sx, SkScalar sy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool SkCanvas::scale </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_sk_scalar_8h.html#a407e363d56d824ed93bd6d1fda2effcf">SkScalar</a>&nbsp;</td>
          <td class="paramname"> <em>sx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_sk_scalar_8h.html#a407e363d56d824ed93bd6d1fda2effcf">SkScalar</a>&nbsp;</td>
          <td class="paramname"> <em>sy</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Preconcat the current matrix with the specified scale. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sx</em>&nbsp;</td><td>The amount to scale in X </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sy</em>&nbsp;</td><td>The amount to scale in Y returns true if the operation succeeded (e.g. did not overflow) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a30e49a6e6274341a4474f58c400315e2"></a><!-- doxytag: member="SkCanvas::setBitmapDevice" ref="a30e49a6e6274341a4474f58c400315e2" args="(const SkBitmap &amp;bitmap)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_sk_device.html">SkDevice</a>* SkCanvas::setBitmapDevice </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sk_bitmap.html">SkBitmap</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>bitmap</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Specify a bitmap for the canvas to draw into. This is a help method for <a class="el" href="class_sk_canvas.html#a9f4c51cdbb30cb193dbb0f17d706a6fc">setDevice()</a>, and it creates a device for the bitmap by calling <a class="el" href="class_sk_canvas.html#ad9a7eb604feaf007bcfacff32d6ee91e">createDevice()</a>. The structure of the bitmap is copied into the device. </p>

</div>
</div>
<a class="anchor" id="a717b592a7f796556b314947b8ce87de0"></a><!-- doxytag: member="SkCanvas::setBounder" ref="a717b592a7f796556b314947b8ce87de0" args="(SkBounder *bounder)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_sk_bounder.html">SkBounder</a>* SkCanvas::setBounder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_sk_bounder.html">SkBounder</a> *&nbsp;</td>
          <td class="paramname"> <em>bounder</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set a new bounder (or NULL). Pass NULL to clear any previous bounder. As a convenience, the parameter passed is also returned. If a previous bounder exists, its reference count is decremented. If bounder is not NULL, its reference count is incremented. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>bounder</em>&nbsp;</td><td>the new bounder (or NULL) to be installed in the canvas </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the set bounder object </dd></dl>

</div>
</div>
<a class="anchor" id="a203027a80c7da9db2f6311448bab45ae"></a><!-- doxytag: member="SkCanvas::setClipRegion" ref="a203027a80c7da9db2f6311448bab45ae" args="(const SkRegion &amp;deviceRgn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SkCanvas::setClipRegion </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sk_region.html">SkRegion</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>deviceRgn</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Helper for clipRegion(rgn, kReplace_Op). Sets the current clip to the specified region. This does not intersect or in any other way account for the existing clip region. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>deviceRgn</em>&nbsp;</td><td>The region to copy into the current clip. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the new clip region is non-empty </dd></dl>

<p>Definition at line <a class="el" href="_sk_canvas_8h_source.html#l00253">253</a> of file <a class="el" href="_sk_canvas_8h_source.html">SkCanvas.h</a>.</p>

</div>
</div>
<a class="anchor" id="a9f4c51cdbb30cb193dbb0f17d706a6fc"></a><!-- doxytag: member="SkCanvas::setDevice" ref="a9f4c51cdbb30cb193dbb0f17d706a6fc" args="(SkDevice *device)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sk_device.html">SkDevice</a>* SkCanvas::setDevice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_sk_device.html">SkDevice</a> *&nbsp;</td>
          <td class="paramname"> <em>device</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Specify a device for this canvas to draw into. If it is not null, its reference count is incremented. If the canvas was already holding a device, its reference count is decremented. The new device is returned. </p>

</div>
</div>
<a class="anchor" id="aff4b429d65d4cc621013c7b6f8248004"></a><!-- doxytag: member="SkCanvas::setDrawFilter" ref="aff4b429d65d4cc621013c7b6f8248004" args="(SkDrawFilter *filter)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_sk_draw_filter.html">SkDrawFilter</a>* SkCanvas::setDrawFilter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_sk_draw_filter.html">SkDrawFilter</a> *&nbsp;</td>
          <td class="paramname"> <em>filter</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the new filter (or NULL). Pass NULL to clear any existing filter. As a convenience, the parameter is returned. If an existing filter exists, its refcnt is decrement. If the new filter is not null, its refcnt is incremented. The filter is part of the state this is affected by save/restore. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>filter</em>&nbsp;</td><td>the new filter (or NULL) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the new filter </dd></dl>

</div>
</div>
<a class="anchor" id="a56ee2bfea2934447dcc573489f55d2bf"></a><!-- doxytag: member="SkCanvas::setMatrix" ref="a56ee2bfea2934447dcc573489f55d2bf" args="(const SkMatrix &amp;matrix)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SkCanvas::setMatrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sk_matrix.html">SkMatrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>matrix</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Replace the current matrix with a copy of the specified matrix. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>matrix</em>&nbsp;</td><td>The matrix that will be copied into the current matrix. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2cbf69015d032a4118dfe0f85c1aed5d"></a><!-- doxytag: member="SkCanvas::setViewport" ref="a2cbf69015d032a4118dfe0f85c1aed5d" args="(int x, int y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool SkCanvas::setViewport </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>y</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>If this subclass of <a class="el" href="class_sk_canvas.html">SkCanvas</a> supports GL viewports, return true and set the viewport to the specified x and y dimensions. If it is not supported, ignore x and y and return false. </p>

</div>
</div>
<a class="anchor" id="a6b33c84811bee5758d57a63a66476c04"></a><!-- doxytag: member="SkCanvas::skew" ref="a6b33c84811bee5758d57a63a66476c04" args="(SkScalar sx, SkScalar sy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool SkCanvas::skew </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_sk_scalar_8h.html#a407e363d56d824ed93bd6d1fda2effcf">SkScalar</a>&nbsp;</td>
          <td class="paramname"> <em>sx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_sk_scalar_8h.html#a407e363d56d824ed93bd6d1fda2effcf">SkScalar</a>&nbsp;</td>
          <td class="paramname"> <em>sy</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Preconcat the current matrix with the specified skew. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sx</em>&nbsp;</td><td>The amount to skew in X </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sy</em>&nbsp;</td><td>The amount to skew in Y returns true if the operation succeeded (e.g. did not overflow) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a25cb80f3795c44ebcadc901cbc3c23f9"></a><!-- doxytag: member="SkCanvas::translate" ref="a25cb80f3795c44ebcadc901cbc3c23f9" args="(SkScalar dx, SkScalar dy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool SkCanvas::translate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_sk_scalar_8h.html#a407e363d56d824ed93bd6d1fda2effcf">SkScalar</a>&nbsp;</td>
          <td class="paramname"> <em>dx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_sk_scalar_8h.html#a407e363d56d824ed93bd6d1fda2effcf">SkScalar</a>&nbsp;</td>
          <td class="paramname"> <em>dy</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Preconcat the current matrix with the specified translation </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dx</em>&nbsp;</td><td>The distance to translate in X </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dy</em>&nbsp;</td><td>The distance to translate in Y returns true if the operation succeeded (e.g. did not overflow) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Friends And Related Function Documentation</h2>
<a class="anchor" id="ad95d8ad7a9afbdcc63b08e57527c89f5"></a><!-- doxytag: member="SkCanvas::SkDrawIter" ref="ad95d8ad7a9afbdcc63b08e57527c89f5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">friend class SkDrawIter<code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_sk_canvas_8h_source.html#l00751">751</a> of file <a class="el" href="_sk_canvas_8h_source.html">SkCanvas.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/core/<a class="el" href="_sk_canvas_8h_source.html">SkCanvas.h</a></li>
</ul>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on Tue Oct 20 11:03:42 2009 for Skia by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>

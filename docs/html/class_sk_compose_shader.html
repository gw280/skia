<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Skia: SkComposeShader Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>SkComposeShader Class Reference</h1><!-- doxytag: class="SkComposeShader" --><!-- doxytag: inherits="SkShader" -->
<p><code>#include &lt;<a class="el" href="_sk_compose_shader_8h_source.html">SkComposeShader.h</a>&gt;</code></p>

<p>Inherits <a class="el" href="class_sk_shader.html">SkShader</a>.</p>
<div class="dynheader">
Collaboration diagram for SkComposeShader:</div>
<div class="dynsection">
<div class="center"><img src="class_sk_compose_shader__coll__graph.png" border="0" usemap="#_sk_compose_shader_coll__map" alt="Collaboration graph"/></div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>

<p><a href="class_sk_compose_shader-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_compose_shader.html#ae6d07da87e78a23b541246390139cc36">SkComposeShader</a> (<a class="el" href="class_sk_shader.html">SkShader</a> *sA, <a class="el" href="class_sk_shader.html">SkShader</a> *sB, <a class="el" href="class_sk_xfermode.html">SkXfermode</a> *mode=NULL)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_compose_shader.html#a072f9716fc2a6685eda30cf4d249cd22">~SkComposeShader</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_compose_shader.html#a31561d7670ab2cae1ffa83642cc2aafa">setContext</a> (const <a class="el" href="class_sk_bitmap.html">SkBitmap</a> &amp;device, const <a class="el" href="class_sk_paint.html">SkPaint</a> &amp;paint, const <a class="el" href="class_sk_matrix.html">SkMatrix</a> &amp;matrix)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_compose_shader.html#a9cce9fb621177dd14e1d4b0cdc8a7a0b">shadeSpan</a> (int x, int y, <a class="el" href="_sk_color_8h.html#a9ec12bd74c4b63b5da802b419106b8ea">SkPMColor</a> result[], int count)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_compose_shader.html#ad552df7b10ebaec214999374999824cc">beginSession</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_compose_shader.html#a267b7a08cbce78532f9b76c190f54db9">endSession</a> ()</td></tr>
<tr><td colspan="2"><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_compose_shader.html#aadcba1154d2916b6c1d168fea90a0005">SkComposeShader</a> (<a class="el" href="class_sk_flattenable_read_buffer.html">SkFlattenableReadBuffer</a> &amp;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_compose_shader.html#aff044268ef9966570cafe866da43ffef">flatten</a> (<a class="el" href="class_sk_flattenable_write_buffer.html">SkFlattenableWriteBuffer</a> &amp;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_sk_flattenable.html#a66e7fa054ae7ef77e452e6e23c2650ad">Factory</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_compose_shader.html#a2a96b7ed223ae8ab995e9edf27060442">getFactory</a> ()</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>This subclass of shader returns the coposition of two other shaders, combined by a xfermode. </p>

<p>Definition at line <a class="el" href="_sk_compose_shader_8h_source.html#l00030">30</a> of file <a class="el" href="_sk_compose_shader_8h_source.html">SkComposeShader.h</a>.</p>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ae6d07da87e78a23b541246390139cc36"></a><!-- doxytag: member="SkComposeShader::SkComposeShader" ref="ae6d07da87e78a23b541246390139cc36" args="(SkShader *sA, SkShader *sB, SkXfermode *mode=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SkComposeShader::SkComposeShader </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_sk_shader.html">SkShader</a> *&nbsp;</td>
          <td class="paramname"> <em>sA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_sk_shader.html">SkShader</a> *&nbsp;</td>
          <td class="paramname"> <em>sB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_sk_xfermode.html">SkXfermode</a> *&nbsp;</td>
          <td class="paramname"> <em>mode</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a new compose shader, given shaders A, B, and a combining xfermode mode. When the xfermode is called, it will be given the result from shader A as its "dst", and the result of from shader B as its "src". mode-&gt;xfer32(sA_result, sB_result, ...) </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>shaderA</em>&nbsp;</td><td>The colors from this shader are seen as the "dst" by the xfermode </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>shaderB</em>&nbsp;</td><td>The colors from this shader are seen as the "src" by the xfermode </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mode</em>&nbsp;</td><td>The xfermode that combines the colors from the two shaders. If mode is null, then SRC_OVER is assumed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a072f9716fc2a6685eda30cf4d249cd22"></a><!-- doxytag: member="SkComposeShader::~SkComposeShader" ref="a072f9716fc2a6685eda30cf4d249cd22" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual SkComposeShader::~SkComposeShader </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aadcba1154d2916b6c1d168fea90a0005"></a><!-- doxytag: member="SkComposeShader::SkComposeShader" ref="aadcba1154d2916b6c1d168fea90a0005" args="(SkFlattenableReadBuffer &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SkComposeShader::SkComposeShader </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_sk_flattenable_read_buffer.html">SkFlattenableReadBuffer</a> &amp;&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="ad552df7b10ebaec214999374999824cc"></a><!-- doxytag: member="SkComposeShader::beginSession" ref="ad552df7b10ebaec214999374999824cc" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SkComposeShader::beginSession </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Called before a session using the shader begins. Some shaders override this to defer some of their work (like calling bitmap.lockPixels()). Must be balanced by a call to endSession. </p>

<p>Reimplemented from <a class="el" href="class_sk_shader.html#ae4623361d1685b9018b7fe1733df8013">SkShader</a>.</p>

</div>
</div>
<a class="anchor" id="a267b7a08cbce78532f9b76c190f54db9"></a><!-- doxytag: member="SkComposeShader::endSession" ref="a267b7a08cbce78532f9b76c190f54db9" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SkComposeShader::endSession </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="class_sk_shader.html#aa106ffb31a4224fb99af9ffa670effd4">SkShader</a>.</p>

</div>
</div>
<a class="anchor" id="aff044268ef9966570cafe866da43ffef"></a><!-- doxytag: member="SkComposeShader::flatten" ref="aff044268ef9966570cafe866da43ffef" args="(SkFlattenableWriteBuffer &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SkComposeShader::flatten </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_sk_flattenable_write_buffer.html">SkFlattenableWriteBuffer</a> &amp;&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Override this to write data specific to your subclass into the buffer, being sure to call your super-class' version first. This data will later be passed to your Factory function, returned by <a class="el" href="class_sk_compose_shader.html#a2a96b7ed223ae8ab995e9edf27060442">getFactory()</a>. </p>

<p>Reimplemented from <a class="el" href="class_sk_shader.html#af623283bd734e89371fef52d10ddaa6c">SkShader</a>.</p>

</div>
</div>
<a class="anchor" id="a2a96b7ed223ae8ab995e9edf27060442"></a><!-- doxytag: member="SkComposeShader::getFactory" ref="a2a96b7ed223ae8ab995e9edf27060442" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_sk_flattenable.html#a66e7fa054ae7ef77e452e6e23c2650ad">Factory</a> SkComposeShader::getFactory </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Implement this to return a factory function pointer that can be called to recreate your class given a buffer (previously written to by your override of <a class="el" href="class_sk_compose_shader.html#aff044268ef9966570cafe866da43ffef">flatten()</a>. </p>

<p>Implements <a class="el" href="class_sk_flattenable.html#a899954e816a929a02e28d835707ca966">SkFlattenable</a>.</p>

<p>Definition at line <a class="el" href="_sk_compose_shader_8h_source.html#l00053">53</a> of file <a class="el" href="_sk_compose_shader_8h_source.html">SkComposeShader.h</a>.</p>

</div>
</div>
<a class="anchor" id="a31561d7670ab2cae1ffa83642cc2aafa"></a><!-- doxytag: member="SkComposeShader::setContext" ref="a31561d7670ab2cae1ffa83642cc2aafa" args="(const SkBitmap &amp;device, const SkPaint &amp;paint, const SkMatrix &amp;matrix)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool SkComposeShader::setContext </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sk_bitmap.html">SkBitmap</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_sk_paint.html">SkPaint</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>paint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_sk_matrix.html">SkMatrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>matrix</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Called once before drawing, with the current paint and device matrix. Return true if your shader supports these parameters, or false if not. If false is returned, nothing will be drawn. </p>

<p>Reimplemented from <a class="el" href="class_sk_shader.html#a875cf60e6f5069af72975b5f06c83262">SkShader</a>.</p>

</div>
</div>
<a class="anchor" id="a9cce9fb621177dd14e1d4b0cdc8a7a0b"></a><!-- doxytag: member="SkComposeShader::shadeSpan" ref="a9cce9fb621177dd14e1d4b0cdc8a7a0b" args="(int x, int y, SkPMColor result[], int count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SkComposeShader::shadeSpan </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_sk_color_8h.html#a9ec12bd74c4b63b5da802b419106b8ea">SkPMColor</a>&nbsp;</td>
          <td class="paramname">[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>count</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Called for each span of the object being drawn. Your subclass should set the appropriate colors (with premultiplied alpha) that correspond to the specified device coordinates. </p>

<p>Implements <a class="el" href="class_sk_shader.html#ada0679ea9f958043db0e6d31bec26dbe">SkShader</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/core/<a class="el" href="_sk_compose_shader_8h_source.html">SkComposeShader.h</a></li>
</ul>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on Tue Oct 20 11:03:42 2009 for Skia by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
